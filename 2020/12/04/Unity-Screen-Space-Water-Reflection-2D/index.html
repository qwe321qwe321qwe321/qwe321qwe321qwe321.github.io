<!DOCTYPE html><html lang="zh-tw"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Unity Screen Space Water Reflection 2D"><meta name="keywords" content="Unity,Gamedev,Shader"><meta name="author" content="PeDev"><meta name="copyright" content="PeDev"><meta name="google-site-verification" content="HvPsLFKP5SVY13dKfPdcZoJCiD1trXxvkXf9ZTeKAtU"><title>Unity Screen Space Water Reflection 2D | PE工具箱</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-158056426-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#成果"><span class="toc-number">1.</span> <span class="toc-text"> 成果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">2.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#目標"><span class="toc-number">3.</span> <span class="toc-text"> 目標</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssr-water-2d-shader實作"><span class="toc-number">4.</span> <span class="toc-text"> SSR Water 2D Shader實作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#screen-space-reflection"><span class="toc-number">4.1.</span> <span class="toc-text"> Screen space reflection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#取得screen-texture"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 取得Screen texture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#從screen-texture反射"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 從Screen texture反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#screen邊界淡化-screen-fade-out"><span class="toc-number">4.1.3.</span> <span class="toc-text"> Screen邊界淡化 Screen Fade Out</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#水面扭曲-water-distortion"><span class="toc-number">4.2.</span> <span class="toc-text"> 水面扭曲 Water Distortion</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sample-displacement"><span class="toc-number">4.2.1.</span> <span class="toc-text"> Sample displacement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#voronoi-noise"><span class="toc-number">4.2.2.</span> <span class="toc-text"> Voronoi Noise</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泡沫或浪花-foam"><span class="toc-number">4.3.</span> <span class="toc-text"> 泡沫或浪花 Foam</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#perspective-correction"><span class="toc-number">4.4.</span> <span class="toc-text"> Perspective Correction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vertex-displacement"><span class="toc-number">4.5.</span> <span class="toc-text"> Vertex displacement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#支援spriterenderer"><span class="toc-number">4.6.</span> <span class="toc-text"> 支援SpriteRenderer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssr-water-2d-c-scripts實作"><span class="toc-number">5.</span> <span class="toc-text"> SSR Water 2D C# scripts實作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#water2dreferenceplanecs"><span class="toc-number">5.1.</span> <span class="toc-text"> Water2DReferencePlane.cs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssrwater2dforspriterenderercs"><span class="toc-number">5.2.</span> <span class="toc-text"> SSRWater2DForSpriteRenderer.cs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssr-water-2d-小結"><span class="toc-number">6.</span> <span class="toc-text"> SSR Water 2D 小結</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#self-sprite-water-reflection-shader實作"><span class="toc-number">7.</span> <span class="toc-text"> Self Sprite Water Reflection Shader實作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#self-sprite-water-reflection-c-script實作"><span class="toc-number">8.</span> <span class="toc-text"> Self Sprite Water Reflection C# Script實作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#總結"><span class="toc-number">9.</span> <span class="toc-text"> 總結</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="PeDev"></div><div class="author-info__name text-center">PeDev</div><div class="author-info__description text-center">who is currently making a 2d platformer game.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">8</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">PE工具箱</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Unity Screen Space Water Reflection 2D</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Unity/">Unity</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/04/Unity-Screen-Space-Water-Reflection-2D/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/04/Unity-Screen-Space-Water-Reflection-2D/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.1k</span><span class="post-meta__separator">|</span><span>Reading time: 11 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="成果"><a class="markdownIt-Anchor" href="#成果"></a> 成果</h1>
<p>我還蠻滿意成果的所以這次放前面</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/n9NKo6sKdl0" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>我實際應用的專案還無法公開，所以影片是拿assets store上的免費素材來做的(連結在說明欄)</p>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>當前專案需求，要在2D遊戲中做一個的水平面反射的效果。</p>
<a id="more"></a>
<p>其實這種教學文或付費Assets還蠻多的，最初是看到這個<a href="https://github.com/StefanJo3107/2D-Water-Shader" target="_blank" rel="noopener">2D-Water-Shader by StefanJo3107</a>的repo，覺得效果還不錯，想說直接拿來用就完事了。</p>
<p>但打開來看了一下，使用起來不是很方便。<br />
他是額外用一個Camera去照水要反射的畫面並輸出在RenderTexture上，之後用他的shader把畫面倒轉+水效果(distortion &amp; foam)並render在一個quad上。</p>
<p>但是這樣的使用流程我不太能接受。因為:</p>
<ol>
<li>用Camera拍反射的畫面意味著Render兩次=Drawcalls翻倍，且這還跟場景中的水面物件數量呈正比。</li>
<li>水的大小被Camera的rect限制</li>
<li>如果我想讓一些前景物件蓋在水面上，需要去額外設定camera的layermask和near far plane，且無法指定render某order in layer範圍的物件。</li>
</ol>
<p>嚴格來說，2.3.的問題都可以寫script來輔助使用，但1.的效能問題就是根本上的無解了。偏偏我的專案使用情景動不動就幾百個物件在畫面中，我可不希望它就因為一個水反射而drawcall翻倍。</p>
<p>所以就想到了Screen space reflection ─ 用螢幕上就有的畫面資訊來反射就足夠了，因為使用情境上幾乎不會有水面高於畫面1/2的情形，所以也不怕會有render不出來的問題。</p>
<p>本來是想直接找找3D Screen space planar reflection來用，因為我的專案是有用到深度的，直接用三維的反射是最理想的方法了。事實上我有在yt上找到<a href="https://www.youtube.com/watch?v=H44kgVaRzYc" target="_blank" rel="noopener">以3D平面反射來做2D遊戲的應用案例</a>，效果看起來是非常不錯的，但它的實作法依然是傳統的利用反射Camera拍畫面的方法。</p>
<p>於是乎又花了點時間去讀了一些3D Screen space planar refelction的教學文，主要是<a href="http://remi-genin.fr/blog/screen-space-plane-indexed-reflection-in-ghost-recon-wildlands/" target="_blank" rel="noopener">這篇 Screen Space Planar Reflections in Ghost Recon Wildlands</a>。寫得很好，但使用前提是建立在有depth map的情況下。其實想想也很合理，要正確的3D反射需要從screen space重建三維世界才能開始，也就是說depth map是必要的。<br />
但要用sprite要產depth map是非常奇怪的事情，所以姑且就放棄了這個方向。</p>
<blockquote>
<p>用transparent的東西(sprite)生成depth map這件事很矛盾，半透明的區域該不該寫入深度?</p>
</blockquote>
<p>總之還是回頭以2D思維來反射吧。</p>
<p>花了點時間看了各式unity教學文+逛Assets Store+一輪以後，實在沒找到半個Screen space的2D reflection，全都是額外用一個camera拍RT的方法。</p>
<p>找不到現成的，那只好自己做一個了。</p>
<h1 id="目標"><a class="markdownIt-Anchor" href="#目標"></a> 目標</h1>
<p>總目標當然是高雄發大財。</p>
<p>條列幾個我希望有的features</p>
<ol>
<li>Screen space reflection: 僅用螢幕的畫面資訊來反射</li>
<li>整個場景中水面的數量不會影響效能</li>
<li>水可以直接用Sprite來定義範圍</li>
<li>反射的水平線要足夠容易設定</li>
<li>能夠簡單地區隔水面以後(以反射線來反射)以及水面以前(無反射)的物件</li>
<li>最好還能夠支援水面上(物件在反射線的下方但是他仍在水面之上)的反射方法</li>
</ol>
<p>第6點可能是最麻煩的，因為水面上的物件的反射水平線是彼此各自獨立的，無法統一用一個pass解決。</p>
<h1 id="ssr-water-2d-shader實作"><a class="markdownIt-Anchor" href="#ssr-water-2d-shader實作"></a> SSR Water 2D Shader實作</h1>
<p>基本的水面Shader我直接使用<a href="https://github.com/StefanJo3107/2D-Water-Shader" target="_blank" rel="noopener">2D-Water-Shader by StefanJo3107</a>來加以改良。</p>
<h2 id="screen-space-reflection"><a class="markdownIt-Anchor" href="#screen-space-reflection"></a> Screen space reflection</h2>
<h3 id="取得screen-texture"><a class="markdownIt-Anchor" href="#取得screen-texture"></a> 取得Screen texture</h3>
<p>這個蠻容易的，我直接使用<a href="https://docs.unity3d.com/Manual/SL-GrabPass.html" target="_blank" rel="noopener"><code>GrabPass</code></a>來取得當下的Screen Texture。</p>
<p>而且用GrabPass有幾個好處:</p>
<ol>
<li>撰寫方便，在Shader內就能寫完，不必寫額外C# script以及來傳遞texture。</li>
<li>可以讓水面只反射在他<strong>後面</strong>(比他早render)的物件。</li>
<li>水面物件可以被cull，當畫面中沒有水面時就不會有開銷。</li>
</ol>
<p>不過當然也有壞處</p>
<ol>
<li>GrabPass本身的效率很低。</li>
<li>畫面上如果有N個水面物件就會有N次擷取。</li>
<li>Multipass無法batching</li>
<li>SRP不支援</li>
</ol>
<p>不過這些壞處對我的影響不大，水面物件非常的少，基本上畫面內應該不會超過3個所以無所謂。</p>
<h3 id="從screen-texture反射"><a class="markdownIt-Anchor" href="#從screen-texture反射"></a> 從Screen texture反射</h3>
<p>接著就是要決定「反射軸」，理想上應該是可以定義任何線為反射線，但我只簡單以Y值決定一個水平線來反射即可。</p>
<p>至於這個Y值應該要以Local space還是World space來定義都各有好處。但考量到多個水面同步的問題，這個Y的值我採用World Space的Y當作Material的屬性，之後會用另一個<code>Reference Water Plane</code>物件的座標來更新這個Y值即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ReferenceWorldY(<span class="string">"Reference Y in World Space"</span>, Float) = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>shader中反射的部分很單純。為了得到Screen space的水平線的Y值為多少，我先把物件的world space position的Y替換成<code>_ReferenceWorldY</code>，再把他從WorldSpace轉到ScreenSpace。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The object's world position = unity_ObjectToWorld._m03_m13_m23</span></span><br><span class="line"><span class="comment">// You can imagine that world position = mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).</span></span><br><span class="line">float4 referenceWS = float4(unity_ObjectToWorld._m03_m13_m23, <span class="number">1</span>);</span><br><span class="line">referenceWS.y = _ReferenceWorldY;</span><br><span class="line">float4 referenceCS = mul(UNITY_MATRIX_VP, referenceWS);</span><br><span class="line">float4 referenceScreenPos = ComputeGrabScreenPos(referenceCS); <span class="comment">// result xy in [0, w]</span></span><br><span class="line"><span class="keyword">float</span> yReferenceSS = referenceScreenPos.y / referenceScreenPos.w; <span class="comment">// divided w to [0, 1]</span></span><br></pre></td></tr></table></figure>
<p>這裡有個技巧是用<code>unity_ObjectToWorld._m03_m13_m23</code>取得物件原點(0, 0)的世界座標，來自<a href="https://forum.unity.com/threads/pivot-world-position.476989/" target="_blank" rel="noopener">這篇</a>。</p>
<blockquote>
<p>可以這樣思考<code>world position = mul(unity_ObjectToWorld, float4(0, 0, 0, 1)) = unity_ObjectToWorld._m03_m13_m23</code></p>
</blockquote>
<p>另外還要注意<code>ComputeGrabScreenPos(float4)</code>回傳的值的xy範圍是[0, w]，所以最後要除w。</p>
<p>得到reference y in screen space後，取得反射的螢幕座標非常簡單。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Relfection Y.</span></span><br><span class="line"><span class="keyword">float</span> refelctionOffset = (yReferenceSS - IN.screenUV.y); <span class="comment">// screenUV是目前的pixel在螢幕上的座標[0, 1]</span></span><br><span class="line"><span class="keyword">float</span> uvY = yReferenceSS + refelctionOffset;</span><br><span class="line">float2 reflectionUV = float2(IN.screenUV.x, uvY);</span><br></pre></td></tr></table></figure>
<h3 id="screen邊界淡化-screen-fade-out"><a class="markdownIt-Anchor" href="#screen邊界淡化-screen-fade-out"></a> Screen邊界淡化 Screen Fade Out</h3>
<p>因為是SSR，所以一定有可能會有超出螢幕外的反射點，這時候會發現邊界有很明顯的落差。</p>
<p>所以要處理的方法就是把接近超出螢幕的像素給淡化，使其是漸漸淡出而不是突然就斷開，跟3D SSR的處理方式差不多。</p>
<p>但因為我們要做的是水，當鏡頭往下移動時我並不希望無法反射的點就直接這樣暴露被水覆蓋的物件。</p>
<p>所以我加了一個<code>Refraction</code>相對於原本的<code>Reflection</code>，當然這裡的<code>Refraction</code>一樣也不是真實物理的折射，也是只是把原先水面後方的物件透過distortion效果來模擬折射效果。</p>
<p>而這個<code>Refraction</code>的權重取決於<code>Reflection</code>的不透明度，當<code>Reflection</code>的不透明度越低(受screen fade out影響)時，<code>Refraction</code>的權重(不透明度)越高。</p>
<p>所以Screen fade out的部分code如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fade out if Closing the bound of screen.</span></span><br><span class="line"><span class="keyword">float</span> reflectionClosingBoundY = max(<span class="number">0</span>, min(<span class="number">1.0</span> - reflectionUV.y, reflectionUV.y));</span><br><span class="line"><span class="keyword">float</span> reflectionBoundFactor = saturate(reflectionClosingBoundY / max(_ScreenBoundFadeOut, <span class="number">0.001</span>));</span><br><span class="line"><span class="keyword">float</span> reflectionWeight = _ReflectionTint.a * reflectionBoundFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Blending reflection and refraction.</span></span><br><span class="line">half4 result;</span><br><span class="line">result.rgb = lerp(refractionColor, reflectionColor, reflectionWeight); <span class="comment">// Determine the result color.</span></span><br></pre></td></tr></table></figure>
<h2 id="水面扭曲-water-distortion"><a class="markdownIt-Anchor" href="#水面扭曲-water-distortion"></a> 水面扭曲 Water Distortion</h2>
<p>這部分我用了兩個方法:</p>
<ol>
<li>原作者的方法，去sample一張displacement texture，來源是<a href="https://forums.tigsource.com/index.php?topic=40539.msg1104986#msg1104986" target="_blank" rel="noopener">Kingdom作者提供的方法</a>。</li>
<li>Voronoi Noise，其實這應該算是動態產生displacement texture並且sample它，YT上有教學是用<a href="https://www.youtube.com/watch?v=-jA72OSTfwk" target="_blank" rel="noopener">ShaderGraph做這個效果</a>。</li>
</ol>
<h3 id="sample-displacement"><a class="markdownIt-Anchor" href="#sample-displacement"></a> Sample displacement</h3>
<p>很簡單實作，而且取得足夠好的displacement texture就能有不錯的效果，demo影片中前景的水面就是使用這套方法。</p>
<h3 id="voronoi-noise"><a class="markdownIt-Anchor" href="#voronoi-noise"></a> Voronoi Noise</h3>
<p>Demo影片開頭的後面的水面就是採用這套方法，這方法的好處是水面的變化可以透過修改voronoi的參數(density, angle)來改變波紋。</p>
<p>至於Voronoi的函式直接去Unity ShaderGraph的<a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@4.1/manual/Voronoi-Node.html" target="_blank" rel="noopener">doc</a>裡面拿，如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> float2 <span class="title">unity_voronoi_noise_randomVector</span> <span class="params">(float2 UV, <span class="keyword">float</span> offset)</span> </span>&#123;</span><br><span class="line">    float2x2 m = float2x2(<span class="number">15.27</span>, <span class="number">47.63</span>, <span class="number">99.41</span>, <span class="number">89.98</span>);</span><br><span class="line">    UV = frac(<span class="built_in">sin</span>(mul(UV, m)) * <span class="number">46839.32</span>);</span><br><span class="line">    <span class="keyword">return</span> float2(<span class="built_in">sin</span>(UV.y*+offset)*<span class="number">0.5</span>+<span class="number">0.5</span>, <span class="built_in">cos</span>(UV.x*offset)*<span class="number">0.5</span>+<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Unity_Voronoi_float</span><span class="params">(float2 UV, <span class="keyword">float</span> AngleOffset, <span class="keyword">float</span> CellDensity)</span> </span>&#123;</span><br><span class="line">    float2 g = <span class="built_in">floor</span>(UV * CellDensity);</span><br><span class="line">    float2 f = frac(UV * CellDensity);</span><br><span class="line">    <span class="keyword">float</span> t = <span class="number">8.0</span>;</span><br><span class="line">    float3 res = float3(<span class="number">8.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">float</span> Out = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">-1</span>; y&lt;=<span class="number">1</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">-1</span>; x&lt;=<span class="number">1</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            float2 lattice = float2(x,y);</span><br><span class="line">            float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);</span><br><span class="line">            <span class="keyword">float</span> d = distance(lattice + offset, f);</span><br><span class="line">            <span class="keyword">if</span>(d &lt; res.x)</span><br><span class="line">            &#123;</span><br><span class="line">                res = float3(d, offset.x, offset.y);</span><br><span class="line">                Out = res.x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> saturate(Out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泡沫或浪花-foam"><a class="markdownIt-Anchor" href="#泡沫或浪花-foam"></a> 泡沫或浪花 Foam</h2>
<p>這部分我直接參考原作者的實作方式，它是仰賴前面Distortion的位移量來決定這個pixel會不會產生浪花。</p>
<p>並且它有加上一個<code>Edge Threshold</code>來使得越靠近反射軸的像素越容易產生浪花，用來模擬靠近岸邊的浪花。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foam</span><span class="params">(inout half3 result, in half4 foamColor, in <span class="keyword">float</span> foamThreshold, in <span class="keyword">float</span> edgeFoamThreshold, in float2 displcementOffset, in <span class="keyword">float</span> point2ReferenceY)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Threshold of foam by sampling displacement texture.</span></span><br><span class="line">    <span class="comment">// The foam occurs when the amount of displacement is too large.</span></span><br><span class="line">    <span class="comment">// Edge foam threshold makes foam happened easily when the uv.y is in the edge threshold.</span></span><br><span class="line">    float2 weight = <span class="built_in">abs</span>(displcementOffset);</span><br><span class="line">    <span class="keyword">float</span> edgeWeight = saturate(point2ReferenceY / max(edgeFoamThreshold, <span class="number">0.001</span>)); <span class="comment">// point2ReferenceY是目前繪製像素到referenceY的距離，edgeFoamThreshold代表這個臨界值的長度，越大則影響越遠。</span></span><br><span class="line">    <span class="keyword">if</span> ((weight.x &gt; foamThreshold &amp;&amp; weight.y &gt; foamThreshold) <span class="comment">// 基本款根據位移量決定浪花</span></span><br><span class="line">        || (edgeWeight &lt; weight.x)) &#123; <span class="comment">// 或是改以edge threshold來判斷位移量是否大到產生浪花(edgeWeight越小代表越接近反射軸)</span></span><br><span class="line">        result.rgb = Blend(foamColor.rgb, result.rgb, foamColor.a); <span class="comment">// blend colors by foam alpha.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至於Voronoi的Foam方法是要另外一套，它不支援岸邊浪花。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VORONOI_NOISE_DISPLACEMENT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FoamVoronoi</span><span class="params">(inout half3 result, in half4 foamColor, in <span class="keyword">float</span> foamThreshold, in float2 samplingDisplacementUV)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// threshold.</span></span><br><span class="line">    <span class="keyword">float</span> voronoiFloat = SampleVoronoiNoise(samplingDisplacementUV);</span><br><span class="line">    <span class="keyword">float</span> weight = max(<span class="number">0</span>,  voronoiFloat - foamThreshold);</span><br><span class="line">    result.rgb = Blend(foamColor.rgb, result.rgb, foamColor.a * weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="perspective-correction"><a class="markdownIt-Anchor" href="#perspective-correction"></a> Perspective Correction</h2>
<p>讓比較下方的像素的流速比較快，比較上方的像素流速較慢，來模擬透視視角。<br />
實作方法參考<a href="https://forums.tigsource.com/index.php?topic=40539.msg1104986#msg1104986" target="_blank" rel="noopener">Kingdom作者提供的方法</a>。</p>
<p>可以直接套式子達成效果:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half2 perspectiveCorrection = half2(<span class="number">2.0f</span> * (<span class="number">0.5</span> - i.uv.x) * i.uv.y, <span class="number">0.0f</span>);</span><br><span class="line">half2 displacement1 = tex2D( _Displacement1Tex, i.uv.xy + perspectiveCorrection).rg;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原理需要圖解比較清楚…</p>
</blockquote>
<h2 id="vertex-displacement"><a class="markdownIt-Anchor" href="#vertex-displacement"></a> Vertex displacement</h2>
<p>事實上原作者還有做這個，方法很簡單就只是在vertex shader內去位移頂點而已。</p>
<p>但是我的應用情景是用在Sprite上，mesh本身的頂點數量不太穩定(MeshType=Tight)，所以不好用就移除了。</p>
<h2 id="支援spriterenderer"><a class="markdownIt-Anchor" href="#支援spriterenderer"></a> 支援SpriteRenderer</h2>
<p>直接參考Unity官方內建的<a href="https://github.com/nubick/unity-utils/blob/master/sources/Assets/Scripts/Shaders/Sprites-Default.shader" target="_blank" rel="noopener">Sprite-Default.shader</a>，把缺少的屬性補上來就OK了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_MainTex(<span class="string">"Alpha Texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">[MaterialToggle] PixelSnap (<span class="string">"Pixel snap"</span>, Float) = <span class="number">0</span></span><br><span class="line">[HideInInspector] _Flip (<span class="string">"Flip"</span>, Vector) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">[PerRendererData] _AlphaTex (<span class="string">"External Alpha"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">[PerRendererData] _EnableExternalAlpha (<span class="string">"Enable External Alpha"</span>, Float) = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[PerRendererData]其實功能跟[HideInInspector]完全一樣，只是方便撰寫者讀懂它將會透過Renderer來傳入資料(MaterialPropertyBlock)</p>
</blockquote>
<h1 id="ssr-water-2d-c-scripts實作"><a class="markdownIt-Anchor" href="#ssr-water-2d-c-scripts實作"></a> SSR Water 2D C# scripts實作</h1>
<h2 id="water2dreferenceplanecs"><a class="markdownIt-Anchor" href="#water2dreferenceplanecs"></a> Water2DReferencePlane.cs</h2>
<ul>
<li>這個類別的主要用途就只是把自身座標提供給Reference World Y給shader使用而已，本身並不是水面物件</li>
<li>為了同步Water的扭曲與水花，會把所有Water shader的參數交給他管理。</li>
<li>可以有多個水面物件參考這個Reference Plane，它們將能夠完美的接合在一起。</li>
</ul>
<h2 id="ssrwater2dforspriterenderercs"><a class="markdownIt-Anchor" href="#ssrwater2dforspriterenderercs"></a> SSRWater2DForSpriteRenderer.cs</h2>
<ul>
<li>會自動產生SpriteRenderer並賦予Shared Material，將能夠支援以Sprite的形狀(根據Alpha)來顯示水面。</li>
<li>有一個<code>Water2DReferencePlane</code>型別的欄位，必須要賦予它參考才能讓水面正確運行。</li>
<li>透過MaterialPropertyBlock來給予做Variant Material Properties。</li>
</ul>
<h1 id="ssr-water-2d-小結"><a class="markdownIt-Anchor" href="#ssr-water-2d-小結"></a> SSR Water 2D 小結</h1>
<p>前面的部分做完後，我們就達成了1~5的條件:</p>
<ol>
<li>Screen space reflection: 僅用螢幕的畫面資訊來反射</li>
<li>整個場景中水面的數量不會影響效能</li>
<li>水可以直接用Sprite來定義範圍</li>
<li>反射的水平線要足夠容易設定</li>
<li>能夠簡單地區隔水面以後(以反射線來反射)以及水面以前(無反射)的物件</li>
</ol>
<p>但 <em>6.最好還能夠支援水面上(物件在反射線的下方但是他仍在水面之上)的反射方法</em> 做不到。</p>
<p>因為很明顯地他的反射軸不一致，反射軸的位置是由Sprite本身的位置決定的，所以沒有辦法只靠一個pass解決。</p>
<p>因此我又寫了一套專門for sprite的自反射水面解決方案 - Self Sprite Water Reflection。</p>
<h1 id="self-sprite-water-reflection-shader實作"><a class="markdownIt-Anchor" href="#self-sprite-water-reflection-shader實作"></a> Self Sprite Water Reflection Shader實作</h1>
<p>…To be continued</p>
<h1 id="self-sprite-water-reflection-c-script實作"><a class="markdownIt-Anchor" href="#self-sprite-water-reflection-c-script實作"></a> Self Sprite Water Reflection C# Script實作</h1>
<p>…To be continued</p>
<h1 id="總結"><a class="markdownIt-Anchor" href="#總結"></a> 總結</h1>
<p>…To be continued</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">PeDev</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://qwe321qwe321qwe321.github.io/2020/12/04/Unity-Screen-Space-Water-Reflection-2D/">https://qwe321qwe321qwe321.github.io/2020/12/04/Unity-Screen-Space-Water-Reflection-2D/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/Gamedev/">Gamedev</a><a class="post-meta__tags" href="/tags/Shader/">Shader</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/14/More-Effective-C-2nd-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/"><i class="fa fa-chevron-left">  </i><span>More Effective C# 筆記 #1 資料型別</span></a></div><div class="next-post pull-right"><a href="/2020/11/22/Unity-AnimationCurve-with-Easing-Functions/"><span>Unity AnimationCurve with Easing Functions</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://qwe321qwe321qwe321.github.io/2020/12/04/Unity-Screen-Space-Water-Reflection-2D/';
  this.page.identifier = '2020/12/04/Unity-Screen-Space-Water-Reflection-2D/';
  this.page.title = 'Unity Screen Space Water Reflection 2D';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'pedevmakesgame' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://pedevmakesgame.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 By PeDev</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="100" alpha="0.4" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
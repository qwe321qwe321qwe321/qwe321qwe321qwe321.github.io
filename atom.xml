<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PE 工具箱</title>
  
  <subtitle>Just a record of the bullshit I encountered in game development.</subtitle>
  <link href="https://qwe321qwe321qwe321.github.io/atom.xml" rel="self"/>
  
  <link href="https://qwe321qwe321qwe321.github.io/"/>
  <updated>2024-08-02T18:06:00.000Z</updated>
  <id>https://qwe321qwe321qwe321.github.io/</id>
  
  <author>
    <name>PeDev</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Discord Webhook 來實現遊戲內 Bug 回報系統</title>
    <link href="https://qwe321qwe321qwe321.github.io/posts/13673/"/>
    <id>https://qwe321qwe321qwe321.github.io/posts/13673/</id>
    <published>2024-08-02T18:06:00.000Z</published>
    <updated>2024-08-02T18:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>不知道有沒有人發現網站右下角可以關燈</em></p><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>先前有幸參與了《<a href="https://store.steampowered.com/app/1809540/_/">九日 Nine Sols</a>》與《<a href="https://store.steampowered.com/app/1610440/Minds_Beneath_Us/">沉沒意志 Minds Beneath us</a>》這兩款今年指標性的國產遊戲的發售前測試，跟著頂尖團隊跑完這樣測試的流程真的蠻有幫助的，有很多值得學習的處理方式。</p><p>不過這篇主要要講的只有 bug 回報的流程。</p><p>在他們實作 In-game Bug Reporter 以前，主要仰賴使用者手動在 <a href="https://discord.com/">Discord</a> 的 Bug Report Forum 當中回報。</p><p><img src="/images/discord-as-bug-reporter/mbu-dc-2.jpg" alt="從 Forum Channel 中填寫標題、內容、截圖、選擇標籤後建立文章" />。</p><blockquote><p>關於如何在 Discord Server 中建立 Forum Channel，請看<a href="https://support.discord.com/hc/zh-tw/articles/6208479917079-%E8%AB%96%E5%A3%87%E9%A0%BB%E9%81%93">官方教學</a></p></blockquote><h1 id="為什麼需要-in-game-bug-reporter遊戲內-bug-回報系統"><a class="markdownIt-Anchor" href="#為什麼需要-in-game-bug-reporter遊戲內-bug-回報系統"></a> 為什麼需要 In-Game Bug Reporter（遊戲內 Bug 回報系統）？</h1><blockquote><p>我開個 Google 表單讓有意願回報的玩家直接回報不就好了，搞這麼麻煩做什麼？</p></blockquote><p>因為有幾個重點是手動外部回報很難做到的事情：</p><ol><li>傳送發生問題的截圖、影片</li><li>傳送發生問題當下的 Log 檔、存檔、硬體資訊等等你在除錯的時候會希望可以調查的任何資料</li></ol><p>當然你也可以在表單<strong>要求</strong>玩家填寫、附上資料，只是這通常就兩種結果：</p><ol><li>太麻煩了不回報了</li><li>附了，但還是不夠精確，成為無法重現或甚至不明白在描述什麼的 bug</li></ol><p>但這樣的結果也不能說是玩家/測試者的錯，這樣歸因也沒有意義。身為開發者也只能盡可能降低回報的阻力以及提升回報的價值，讓有意願回報的玩家能夠順利的回報，開發者也能順利的從回報資料中找到發生 bug 的原因。</p><h1 id="bug-回報系統的需求"><a class="markdownIt-Anchor" href="#bug-回報系統的需求"></a> Bug 回報系統的需求</h1><p>回報流程的需求列出來大致上有：</p><ol><li>User Interface<ol><li>照遊戲專案需求來設計</li></ol></li><li>發送/接收 bug report 的 API<ol><li>方便使用</li><li>安全性，防止被惡意攻擊</li></ol></li><li>儲存方式<ol><li>價格</li><li>方便檢索、後續整合</li><li>隱私與資料安全</li></ol></li></ol><p>綜合以上幾點，九日開發團隊的<a href="#%E9%8A%98%E8%AC%9D-acknowledgement">易衡</a>提出了「既然手動回報都在 Discord 了，那乾脆直接拿 Discord 來做這件事情吧」<br />（主要參考 <a href="https://hades.fandom.com/wiki/Support">Hades</a> 的回報流程，他們盡可能將其他的回報管道統一引導至同個地方，來降低整理資料的麻煩）</p><p>實際嘗試了之後確定這件事情感覺超級可行的，以 Discord 來達成根據上面需求的話大致是這樣：</p><ol><li>User Interface<ol><li>照遊戲專案需求來設計 -&gt; 無關</li></ol></li><li>發送/接收 bug report 的 API -&gt; <a href="https://discord.com/developers/docs/resources/webhook">Discord Webhook</a><ol><li>方便使用 -&gt; 需要一個 for Unity/C# 的 Discord webhook library ，所以我寫了一套開源 <a href="https://github.com/qwe321qwe321qwe321/Unity-DiscordWebhook">Unity-DiscordWebhook</a></li><li>安全性，防止被惡意攻擊 -&gt; 危，這點稍後補充</li></ol></li><li>儲存方式 -&gt; Discord Channels<ol><li>價格 -&gt; 完全免費</li><li>方便檢索、後續整合 -&gt; Discord Forum 本身的介面就已經很 user-friendly （有標籤、有搜尋功能）了，後續整合可以透過 <a href="https://support.discord.com/hc/zh-tw/articles/212889058-Discord%E5%AE%98%E6%96%B9API">Discord API</a> 去爬資料</li><li>隱私與資料安全 -&gt; Discord 本身可以限制各頻道權限，敏感資訊可以送到私密頻道；資安的部分是 Discord 要負責也不關我的事</li></ol></li></ol><p>總之這套流程實驗下來非常可行，因此才有這篇文章想要推廣這套方法給更多開發者，接下來細項解釋<strong>就我所知</strong>各步驟的實現方式。</p><h1 id="各步驟的實現"><a class="markdownIt-Anchor" href="#各步驟的實現"></a> 各步驟的實現</h1><h2 id="user-interface"><a class="markdownIt-Anchor" href="#user-interface"></a> User Interface</h2><p>很看專案自己的實作方式，像 Hades 的 <a href="https://hades.fandom.com/wiki/Support">Bug Reporter</a> 就是個很優秀的案例。<br /><img src="/images/discord-as-bug-reporter/hades2-ui.jpg" alt="Hades II 在遊戲中按下 F10 開啟 Bug Reporter" /></p><p>這裡面包含了：</p><ul><li>截圖，Hades 這套工具甚至允許你直接在上面畫線加註</li><li>選填的 Email ，讓使用者有辦法後續追蹤</li><li>Bug 描述的輸入框</li><li>Submit 按鈕</li><li>寫明你會送出的資料（存檔以及系統診斷）以及宣告資料的使用目的（僅用於調查此回報項目）。<ul><li>這一點尤其重要，會牽涉到個資法的問題，如歐盟的 <a href="https://en.wikipedia.org/wiki/General_Data_Protection_Regulation">GDPR</a>。</li></ul></li></ul><h2 id="發送方式discord-webhook"><a class="markdownIt-Anchor" href="#發送方式discord-webhook"></a> 發送方式：Discord Webhook</h2><ul><li><a href="https://discord.com/developers/docs/resources/webhook">Webhook Resource</a></li><li><a href="https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks">如何在你的 Discord 伺服器加入 Webhook</a></li></ul><p>簡單說這個東西就是：你可以在 Discord 頻道設定內加入 Webhook ，之後可以透過 Webhook API 來發送訊息至該頻道。</p><h3 id="方便使用"><a class="markdownIt-Anchor" href="#方便使用"></a> 方便使用</h3><p>為了在 Unity 上方便使用，我寫了一套 Unity 版本的 Library – <a href="https://github.com/qwe321qwe321qwe321/Unity-DiscordWebhook">Unity-DiscordWebhook</a>。</p><p>用起來還蠻方便的（自己說），除了我們自己的 Bionic Bay 之外《九日 Nine Sols》與《沉沒意志 Minds Beneath us》也都是使用這套來實作自己的 in-game bug reporter，拿來幫我背書：）</p><p><strong>題外話</strong></p><p>我在寫了差不多 6 成的時候才想到應該先查一下 Asset Store 上有沒有，而也真的已經有一套 <a href="https://assetstore.unity.com/packages/tools/integration/webhooks-for-discord-246019">Webhooks for Discord</a>，而且它寫法和我 87% 像都是 builder pattern，但實際上我並沒有買過那套插件只能從商店截圖來猜它的功能性。</p><p>帶猜測性的比較：</p><table><thead><tr><th>Feature</th><th>Unity-DiscordWebhook</th><th>Webhooks for Discord</th></tr></thead><tbody><tr><td>Embeds</td><td>還未支援（看情況未來更新）</td><td>Yes ✅</td></tr><tr><td>Awaitable</td><td>Yes ✅</td><td>No</td></tr><tr><td>Upload Files</td><td>支援檔案路徑、Byte Array、Texture 為參數 ✅</td><td>僅支援檔案路徑為參數</td></tr><tr><td>Helper</td><td>自帶一鍵 screenshot, zip 功能 ✅</td><td>我不知道</td></tr><tr><td>Price</td><td>Free ✅✅✅✅✅✅✅✅✅✅</td><td>4.99 USD</td></tr><tr><td>Long-Term Support</td><td>問作者</td><td>問作者（付費插件應該比較在乎）</td></tr></tbody></table><p>功能面上身為一個 Web Request API 卻沒有 Awaitable method 我就不採納了，其他功能都是實作過程中有需要才補上的。</p><blockquote><p>查到其他 github 上的開源專案還有 <a href="https://github.com/lumpn/unity-discord">lumpn/unity-discord</a>、<a href="https://github.com/T3R1X/UnityDiscordMsgSender">T3R1X/UnityDiscordMsgSender</a>、<a href="https://github.com/MorganSkilly/Unity-Discord-Webhook-System">MorganSkilly/Unity-Discord-Webhook-System</a>，它們基本上都缺少關鍵功能（例如上傳檔案）或是壞了，而且我就想寫成 builder pattern 比較爽。</p></blockquote><h3 id="安全性防止被惡意攻擊"><a class="markdownIt-Anchor" href="#安全性防止被惡意攻擊"></a> 安全性，防止被惡意攻擊</h3><p>針對這個 webhook 能想到的惡意攻擊主要就瘋狂洗版來癱瘓有效資訊的取得，而想要不被惡意攻擊我能想到就兩個方向：</p><ol><li>擋住惡意攻擊本身，讓接收端要去偵測並封鎖惡意攻擊。<ol><li>這一點我沒有很熟，但我知道你管不到 Discord 怎麼接收訊息，所以你能做的是<strong>避免直接暴露 Webhook 連結</strong>，你會需要一個中間層去接收來自 client 的訊息、經過處理、篩選後再轉送至 Webhook 連結。</li><li>現在網路上有很多 Serverless Function 的服務可以做到這件事，如 <a href="https://vercel.com/docs/rest-api">Vercel REST API</a>，但我沒有研究這塊，有興趣的請找<a href="#%E9%8A%98%E8%AC%9D-acknowledgement">易衡</a>。</li></ol></li><li>擋住惡意使用者，一開始就把使用者限縮到可信任的圈圈內<ol><li>即內部團隊人員、可信任的測試者等等，說白話就是什麼都不管、兩手一攤、我相信人性本善之術。</li></ol></li></ol><p>我們大部分都只會把系統開放給內部測試玩家，所以基本上都是基於 2. 的方向什麼都沒處理也很省事。即便、就算、萬一、哪怕還是出現了惡意攻擊，你身為管理員也可以立刻從 Discord 頻道設定中把該 Webhook 給註銷掉及時停損，我覺得應該是可以接受的風險。</p><h2 id="儲存方式discord-forum-channels"><a class="markdownIt-Anchor" href="#儲存方式discord-forum-channels"></a> 儲存方式：Discord Forum &amp; Channels</h2><p>這部分其實也看專案想要怎麼處理這些資訊。</p><p>拿沉沒意志的案例來說，發一個 bug report 會自動在名叫「內部bug回報-bug-report」的 forum 當中開一篇文章，且會自動附上版本號、當下截圖、流程位置、硬體配備、存檔、Player.log 這些重要的 debug 資訊。<br /><img src="/images/discord-as-bug-reporter/mbu-dc.jpg" alt="MBU 內測回報系統" /></p><p>後面 <a href="#%E6%B2%89%E6%B2%92%E6%84%8F%E5%BF%97-minds-beneath-us">Showcasing</a> 有完整流程截圖。</p><h3 id="可追蹤性-匿名性"><a class="markdownIt-Anchor" href="#可追蹤性-匿名性"></a> 可追蹤性 / 匿名性</h3><p>目前這套流程比較麻煩的點是透過 webhook 發出的回報<strong>並不會直接連結到使用者帳號</strong>，所以後續如果希望和該回報者確認錯誤的細節的話會比較難聯繫上。</p><p><strong>但…這也是優點！</strong></p><p>第一，非常有可能玩家是<strong>沒有 discord 帳號的</strong>，你不會希望要求所有玩家想回報問題都得辦個 Discord 帳號；此外，就是有人想要<strong>匿名回報</strong>，如果強行要求帳號制回報的話也會成為那些人回報的阻力。</p><p>所以現在我們認為可接受的方式還是讓使用者自己填 Username 或是期待他們主動在回報討論串留言補充資訊（例如影片）。</p><blockquote><p>當你要把這個服務推到全世界玩家使用的情況，匿名性尤其重要。<br />有非常多國家的個資法是有明確規範你要如何處理「<strong>個人資料</strong>」，一旦你上傳的資料牽扯到<strong>個資</strong>就必須套用他們的規則來給予使用者相對應的權利，最常見的就是歐盟的 <a href="https://en.wikipedia.org/wiki/General_Data_Protection_Regulation">GDPR</a>。<br />有興趣看到底還有哪些隱私權政策可以直接參考 Unity 的法律資訊 <a href="https://unity.com/cn/legal/game-player-and-app-user-privacy-policy">Game Player and App User Privacy Policy</a>，裡面涵蓋了非常多不同國家法律所要求的權利。<br />總而言之完全不建議將送出任何含個人資料的內容，除非你確認過你的使用區域沒有相關的個資法來約束。</p></blockquote><h3 id="隱私與資料安全"><a class="markdownIt-Anchor" href="#隱私與資料安全"></a> 隱私與資料安全</h3><p>如果使用者範圍很小或者不介意的話（假如只有內部人員使用），是不太需要關心這個議題。</p><p>若此回報系統是公開給大量玩家使用的情況下，建議避免將一些比較敏感的資訊直接放在公開頻道。<br />例如，或許有些玩家不希望暴露自己的硬體規格或者不希望自己的存檔被公開給非開發者的人存取，這樣會增加玩家回報的阻力。即便回報本身的資料是匿名無法追蹤的，也會變相讓這些玩家<strong>不願主動現身</strong>補充說明。</p><p>想解決這個問題的話可以先把資料送到開發者的私人頻道、然後 Forum 文章內容再去連結那則訊息，這樣沒有權限的人就只會看到「無存取權限」，例如：<br /><img src="/images/discord-as-bug-reporter/ns-dc.jpg" alt="九日使用的回報系統就採用這種形式" /></p><h3 id="資料檢索-後續整合"><a class="markdownIt-Anchor" href="#資料檢索-後續整合"></a> 資料檢索、後續整合</h3><p>首先 Discord 本身介面就有蠻強大的搜尋以及標籤功能了，如果沒有整合需求的話我覺得挺堪用的。</p><p>若想要把這裡回報的 bug 資料整合至團隊內部使用的其他服務，可以透過 <a href="https://support.discord.com/hc/zh-tw/articles/212889058-Discord%E5%AE%98%E6%96%B9API">Discord API</a> 來爬這些資訊，我沒有做這件事就不展開來談了（去問<a href="#%E9%8A%98%E8%AC%9D-acknowledgement">易衡</a>）。</p><h1 id="showcasing"><a class="markdownIt-Anchor" href="#showcasing"></a> Showcasing</h1><h2 id="bionic-bay-換影循跡"><a class="markdownIt-Anchor" href="#bionic-bay-換影循跡"></a> <a href="https://store.steampowered.com/app/1928690/Bionic_Bay/">Bionic Bay 換影循跡</a></h2><p>按下 F8 會截圖然後彈出回報視窗，這實作比較簡陋只需要填 username （透過 PlayerPrefs 儲存所以一台電腦只要填一次）然後選擇送出至哪個頻道。</p><table><thead><tr><th>In-game UI</th><th>Discord</th></tr></thead><tbody><tr><td><img src="/images/discord-as-bug-reporter/bb-ui.jpg" alt="關卡編輯器內 F8 叫出來" /></td><td><img src="/images/discord-as-bug-reporter/bb-dc.jpg" alt="Discord 查看回報內容" /></td></tr></tbody></table><p>實際上會送出的資料如下圖：</p><ul><li>回報者 Username</li><li>版本號</li><li>回報的地點（關卡、角色座標、相機位置），複製 code 可以在遊戲中快速傳送到指定地點</li><li>回報當下的截圖</li><li>附件內有 Player.log 、硬體規格（CPU、GPU、RAM、VRAM、OS、Resolution、Refresh Rate）</li></ul><p>這我們自己專案的給團隊成員使用的實作，所以比較有辦法講比較細。沒有特別在遊戲內加入 text field 是因為使用者就是我們團隊本身，要我在遊戲內打字我還不如直接去 discord 頻道回覆補充說明就好。</p><p>這個系統也常常被我們拿來當快速截圖、傳送 Player.log 的方式，我是真心很喜歡這個流程，省下以前一大堆的資訊傳遞缺失的麻煩。</p><h2 id="九日-nine-sols"><a class="markdownIt-Anchor" href="#九日-nine-sols"></a> <a href="https://store.steampowered.com/app/1809540/_/">九日 Nine Sols</a></h2><table><thead><tr><th>In-game UI</th><th>Discord</th></tr></thead><tbody><tr><td><img src="/images/discord-as-bug-reporter/ns-ui-1.jpg" alt="遊戲內叫出來" /> <img src="/images/discord-as-bug-reporter/ns-ui-2.jpg" alt="送出後" /></td><td><img src="/images/discord-as-bug-reporter/ns-dc.jpg" alt="在官方 Discord 中查看回報內容" /></td></tr></tbody></table><ul><li>使用者可以寫下暱稱、標題與 bug 描述。</li><li>送出後可以透過按鈕直接連結到該回報的文章</li><li>記錄了版本號、截圖、硬體規格、遊戲存檔。</li></ul><h2 id="沉沒意志-minds-beneath-us"><a class="markdownIt-Anchor" href="#沉沒意志-minds-beneath-us"></a> <a href="https://store.steampowered.com/app/1610440/Minds_Beneath_Us/">沉沒意志 Minds Beneath Us</a></h2><table><thead><tr><th>In-game UI</th><th>Discord</th></tr></thead><tbody><tr><td><img src="/images/discord-as-bug-reporter/mbu-ui-1.jpg" alt="內測版遊戲內 Ctrl+F6 叫出來" /> <img src="/images/discord-as-bug-reporter/mbu-ui-2.jpg" alt="送出後" /></td><td><img src="/images/discord-as-bug-reporter/mbu-dc.jpg" alt="在官方 Discord 中查看回報內容" /></td></tr></tbody></table><p>（感謝 <a href="#%E9%8A%98%E8%AC%9D-acknowledgement">Ta David Yu</a> 提供圖片、<a href="https://github.com/qwe321qwe321qwe321/Unity-DiscordWebhook?tab=readme-ov-file#minds-beneath-us">影片</a>）</p><ul><li>使用者可以選擇要回報的標籤（tags）、回報者名稱、回報標題</li><li>送出後可以透過按鈕直接連結到該回報的文章，因為 UI 只給能填寫標題所以鼓勵回報者主動在該文章底下補充資訊</li><li>有額外一個「不再顯示這個視窗」的勾選框，貼心</li><li>記錄了版本號、當下截圖、目前流程位置、硬體規格、存檔、Player.log 這些重要的 debug 資訊</li></ul><p><em>之後若還有其他可展示的案例一律會放在 <a href="https://github.com/qwe321qwe321qwe321/Unity-DiscordWebhook?tab=readme-ov-file#whos-using-unity-discordwebhook">github repository</a> 上更新。</em></p><h1 id="總之就是"><a class="markdownIt-Anchor" href="#總之就是"></a> 總之就是</h1><p>我覺得這整套流程蠻值得學(抄)習(來)使用的，尤其小團隊沒有太多時間去研究整套流程和一些 know-hows，之後若有更多開發者進來使用後能碰撞出更優秀的解決方案那就好了。</p><p>雖然這篇文章本身並沒有針對「怎麼實作」這件事著墨太多，有興趣的看看 <a href="https://github.com/qwe321qwe321qwe321/Unity-DiscordWebhook">Unity-DiscordWebhook</a> 的 README（雖然我還沒寫中文版，真有需要的話我再補）。</p><h1 id="銘謝-acknowledgement"><a class="markdownIt-Anchor" href="#銘謝-acknowledgement"></a> 銘謝 Acknowledgement</h1><ul><li><a href="https://www.facebook.com/jerry.chan.90834">jerryee 易衡</a> – 流程發想者，有額外問題都去問他</li><li><a href="https://github.com/ta-david-yu">Ta David Yu</a> – 實際應用、協助測試功能與提供相關截圖影片</li><li><a href="https://x.com/randomdevdk">DK Liao</a> – 實際應用與協助測試功能</li><li><a href="https://github.com/yorube">Yorube</a> 校閱</li><li>《<a href="https://store.steampowered.com/app/1809540/_/">九日 Nine Sols</a>》與《<a href="https://store.steampowered.com/app/1610440/Minds_Beneath_Us/">沉沒意志 Minds Beneath us</a>》 團隊授權公開他們的 Bug Reporter 與 Discord 截圖</li></ul><hr /><p>其實我是要假借這篇文宣傳<a href="https://store.steampowered.com/app/1610440/Minds_Beneath_Us/">沉沒意志</a>，他們在經歷了六年的開發期後終於在 7 月 31 日的時候上線了。</p><iframe src="https://store.steampowered.com/widget/1610440/" width="100%" height="190" frameborder="0" loading="lazy" allowfullscreen></iframe><p>Steam 連結: <a href="https://store.steampowered.com/app/1610440/Minds_Beneath_Us/">https://store.steampowered.com/app/1610440/Minds_Beneath_Us/</a></p><p>他們是學生團隊畢業開公司繼續製作當初的畢製，年紀比我大一屆，經歷了如此漫長的六年開發期後終於上市了。<br />說實話我也才跟他們的開發者認識不到一年，甚至比較常聊也是近三個月左右才開始的，還是很為他們感到高興。我自認蠻清楚這種長時間開發下對自己專案的鈍感與不安會讓腦子不太正常，不管最後成績如何，成功上市就已經算某種程度的大解脫了。</p><p>今年真的是國產精品獨立遊戲大爆發的一年，雖然幾乎都是 N 年磨一劍這種超不健康的開發週期下所磨出來的作品 – 開發週期長是個選擇，但朝著一個過去沒有做過的方向直接全職耗費 N 年的時間真的是一件很可怕的事。不過結果論來說還是很高興能看到這些作品的出現能為整個產業帶來一點什麼<br />– 我希望如此。</p><p>也不禁感嘆旁邊幾個紛紛畢業了，自己怎麼還在這。</p><blockquote><p>最後強調一下遊戲名是「<a href="https://store.steampowered.com/app/1610440/Minds_Beneath_Us/">沉沒意志</a>」，不是「<a href="https://www.google.com/search?q=%E6%B2%89%E9%BB%98%E6%84%8F%E5%BF%97">沉默意志</a>」不是「<a href="https://www.google.com/search?q=%E6%B2%88%E6%B2%92%E6%84%8F%E5%BF%97">沈沒意志</a>」不是「<a href="https://www.google.com/search?q=%E6%B2%89%E6%B2%92%E6%8A%91%E5%88%B6">沉沒抑制</a>」不是「<a href="https://www.google.com/search?q=%E9%99%B3%E8%8E%AB%E6%84%8F%E5%BF%97">陳莫意志</a>」，是「<a href="https://store.steampowered.com/app/1610440/Minds_Beneath_Us/"><strong>沉沒意志</strong></a>」。<br />：好的，沉默意志。</p></blockquote>]]></content>
    
    
    <summary type="html">先前有幸參與了《九日 Nine Sols》與《沉沒意志 Minds Beneath us》這兩款今年指標性的國產遊戲的發售前測試，當中有很多值得學習的處理方式，這篇將介紹如何使用 Discord Webhook 來實現 Bug Reporter。</summary>
    
    
    
    
    <category term="Unity" scheme="https://qwe321qwe321qwe321.github.io/tags/Unity/"/>
    
    <category term="Gamedev" scheme="https://qwe321qwe321qwe321.github.io/tags/Gamedev/"/>
    
    <category term="C#" scheme="https://qwe321qwe321qwe321.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>從移動和跳躍開始，做好 2D 平台跳躍遊戲的角色控制 _BB001</title>
    <link href="https://qwe321qwe321qwe321.github.io/posts/61013/"/>
    <id>https://qwe321qwe321qwe321.github.io/posts/61013/</id>
    <published>2023-07-22T09:54:57.000Z</published>
    <updated>2023-07-22T09:54:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p><em>長文、多 GIF 圖注意，建議用電腦版網頁瀏覽，網頁右側和文章開頭有目錄可以先看。</em></p><p>這是第一篇有關《<a href="https://store.steampowered.com/app/1928690/Bionic_Bay/?utm_source=pedevsite&amp;utm_medium=post&amp;utm_campaign=bb001">Bionic Bay: 換影循跡</a>》的開發日誌，想了一下還是從最基本的<strong>角色控制</strong>（Character Controller）開始介紹好了。</p><p>不過第一篇我還是想先介紹一下優秀 2D 平台跳躍遊戲的角色控制會用到的一些通用知識，主要都是整理自網路上的資源和我實際在 Bionic Bay 上的應用。</p><blockquote><p>這篇文章純討論角色控制、角色物理，<strong>不會包含</strong>「角色動畫」、「攝影機」、「Game Feel」等等其他知識。<br />另外雖然這篇要講的是 2D 橫向遊戲，實際上這些知識在 3D 角色控制也通用（我實作上也是從 3D 角色控制那邊偷了不少）。</p></blockquote><h1 id="只是個-2d-遊戲的角色控制是能多複雜"><a class="markdownIt-Anchor" href="#只是個-2d-遊戲的角色控制是能多複雜"></a> 只是個 2D 遊戲的角色控制是能多複雜？</h1><p>這邊先放一段 Bionic Bay 角色控制的測試影片：</p><div class="video-container"><iframe src="https://www.youtube.com/embed/Igobi3XOqpQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>在這個測試場景中只有角色有掛 scripts ，其他所有動態物件都只是 Rigidbody2D 和 Joint2D 的組合。<br />換句話說，這個角色控制器（Character Controller）並不仰賴於特定場景配置（唯一需要的是物件必須是由物理引擎驅動），隨時放進去任意場景都至少會有以下功能：</p><ul><li>能夠順利通過凹凸不平的地形。</li><li>都能夠站穩在任何物體上，無論是否會移動（只要速度不要太快）。</li><li>只要角度正確就能攀附邊角（Ledge Grab）、牆壁滑行（Wall Slide）、蹬牆跳躍（Wall Jump）。</li><li>站在（或是掛在）物體之上時能夠正確地對該物體施力。</li><li>離開移動中的物體時保有正確的慣性速度。</li><li>當站立的物體速度過快時會被甩出去。</li></ul><p>為了做到這件事情，請見下圖：</p><p><img src="/images/bb-001-character-controller/01.png" alt="" /></p><p>這是 Bionic Bay 的<strong>主角物理控制器</strong>的腳本（不含外觀、動畫和 Input 管理）在 Inspector 的樣子。<br />各個 Module 對應單一功能，有些 Module 雖然實作了不過目前沒用上（沒打勾）。</p><p>稍微摘要各個 Module 功能：</p><table><thead><tr><th>Module</th><th>Description</th></tr></thead><tbody><tr><td>Hero Movement</td><td>角色移動的核心模組（提供角色速度、旋轉、四方向的接觸狀態、移動函數、碰撞檢測）。</td></tr><tr><td>Horizontal Movement</td><td>控制角色水平方向（左右）的速度、加速度。</td></tr><tr><td>Gravity</td><td>控制角色承受的重力、垂直方向速度（不使用內建重力）。</td></tr><tr><td>Jump</td><td>控制普通跳躍的強度、高度。</td></tr><tr><td>Jump Holding</td><td>跳躍後如果未按住跳躍鍵會快速消耗目前上升速度。</td></tr><tr><td>Wall Slide</td><td>角色滑行於左右兩側的牆壁的功能。</td></tr><tr><td>Wall Jump</td><td>控制牆壁滑行狀態下的跳躍。</td></tr><tr><td>Edge Climber</td><td>（未實裝）這是學 Ori 的實作，人物靠近牆壁與地面轉角的時候如果有按住跳躍鍵則會自動上升推進一小段。</td></tr><tr><td>Ground Connector</td><td>使角色得以<strong>站立於任何物件之上並隨之移動</strong>的系統，也涉及進入、離開動態地面的慣性運動。</td></tr><tr><td>Ledge Grab</td><td>角色可以用手攀附住<strong>符合角度的任意物體邊緣</strong>的系統。</td></tr><tr><td>Ledge Jump</td><td>攀附狀態的跳躍。</td></tr><tr><td>Crouch</td><td>蹲下功能，包含爬行功能。</td></tr><tr><td>Push</td><td>以動態調整的力道<strong>推動任意動態物件</strong>的系統（實際上遊戲沒用到）。</td></tr><tr><td>Slip</td><td>在地面上滑行的功能（當站在過於顛頗的地面時觸發）。</td></tr><tr><td>Slip Jump</td><td>控制地面滑行的跳躍。</td></tr><tr><td>Body Interpolator</td><td>自行實作 Rigidbody.interpolation 的功能（因為一些理由不允許使用內建的）。</td></tr><tr><td>Contact Colliders</td><td>儲存當前與角色有碰撞的所有 Collider 列表。</td></tr><tr><td>Dash</td><td>角色突進翻滾的功能。</td></tr><tr><td>Dash Holding</td><td>（未實裝）若玩家沒有按住按鍵則會縮短翻滾距離的功能。</td></tr><tr><td>Controllable Dash</td><td>玩家在翻滾過程中可以<strong>直接透過方向鍵調整突進距離</strong>的功能。</td></tr><tr><td>Capsule Collider Resizer</td><td>調整角色 Collider 大小的功能，用於蹲下、移動縮小 Collider。</td></tr><tr><td>Preswap</td><td>遊戲中的「標記」（或稱攻擊）動作。</td></tr><tr><td>Ragdoll</td><td>就 Ragdoll 功能，之後開一篇來講。</td></tr><tr><td>Roll</td><td>這是從 Dash 中再切出來的滾動狀態，主要是供 Bounce ray 等特殊情況下的滾動狀態使用。</td></tr></tbody></table><p>我相信有戰鬥系統的動作遊戲會更複雜，Bionic Bay 側重的點只有跑酷體驗所以只針對它強化。<br />不打算把所有功能都展開來聊，這第一篇文章會先以一個（我認為）最基本的橫向卷軸跳躍遊戲應該要處理好的系統開始介紹 – 也就是「移動」和「跳躍」。</p><blockquote><p>這些模組、角色物理控制也是從開案初期（2019）直到最近幾個月都還有持續調整的一個系統，非常有可能在我介紹完以後又有功能調整。</p></blockquote><h1 id="移動與跳躍是能有多複雜"><a class="markdownIt-Anchor" href="#移動與跳躍是能有多複雜"></a> 移動與跳躍？是能有多複雜？</h1><p>2D 橫向卷軸 / 平台跳躍遊戲是一個非常容易入門的類型，但非常可惜的是有太多案例是連最基本的這兩件事情都沒做好，不太確定到底是線上的教學參差不齊還是有什麼問題。因為要做好這件事情基本上也不會涉及什麼很難懂的概念或實作，都單純是「如果你沒有做，那只是因為你不知道可以這樣做」的知識而已。</p><p>以前一些 know-how 的資源比較分散，不過自從 GMTK 做了這個 <a href="https://gmtk.itch.io/platformer-toolkit">Platformer Toolkit</a> 之後我都直接推他。</p><div class="video-container"><iframe src="https://www.youtube.com/embed/zWi0jgghGcI" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p><a href="https://gmtk.itch.io/platformer-toolkit">https://gmtk.itch.io/platformer-toolkit</a><br />英文看的懂的話，<strong>強 烈 建 議 去 操 作 一 遍</strong>。<br />（然後建議下載 Standalone 執行檔，因為 WebGL 的版本閹割了一些東西）</p><p>另外推薦一個很少看過有人分享的參考資料：<a href="http://martinf.dk/jump/">You Say Jump, I Say How High?</a>，是一篇 2015 年發表專門研究 2D 平台跳躍遊戲的跳躍和移動參數的論文，他本身就提及很多 know-how 了，然後嚴謹程度是從「定義參數」、「測量參數的方法」到「測量得出幾款經典遊戲的移動、跳躍參數」，都超爆幹詳細的那種，很值得讀。</p><p>接下來我就借用一下這個 Toolkit 和那篇論文來介紹幾個重要知識點。</p><h1 id="1-水平移動的速度參數"><a class="markdownIt-Anchor" href="#1-水平移動的速度參數"></a> 1. 水平移動的速度參數</h1><p><img src="/images/bb-001-character-controller/platformer_toolkit_1.gif" alt="Platformer Toolkit 的速度設定畫面" /><br />最基本的東西，讓你的角色左右移動的時候會有比較順滑自然的感受，幾乎每一個橫向卷軸遊戲都會有自己一套參數組。</p><p>我常用的參數跟 GMTK 一致，分別有：</p><ul><li>最高速度（Max Speed）：就可控制的上限速度。</li><li>加速度（Acceleration）： 在速度 0 到最高速度之間，方向鍵持續按住的情況下的加速度（每秒提升多少速度）。</li><li>減速度（Deceleration）： 在速度 0 到最高速度之間，放開方向鍵時的減速度（每秒降低多少速度）。</li><li>轉向加速度（Turn Acceleration 或 Turn Speed）：當目前角色移動方向與輸入方向不同的時候的加速度。</li></ul><p>然後 GMTK 這裡在空中移動時的水平移動參數是用另一組，分別是 Air Acceleration 、 Air Control 、Air Brake。<br />這裡我不確定它們實際上的數值意義，我體感大致分別是「空中狀態的加速度」、「空中狀態的轉向加速度」、「空中狀態的減速度」。</p><p>但我不知道為什麼他要用三個新名詞，我 Bionic Bay 這邊的做法是「地面上」和「空中」狀態分別都有自己一組同名參數，如下圖。</p><p><img src="/images/bb-001-character-controller/horizontal_movement_2.png" alt="Bionic Bay 主角的速度參數（先無視 Extra Max Speed，之後別篇再解釋）" /><br />上面這組速度參數的效果是要做成：</p><ul><li>地面上的左右移動反應比較即時（加減速度都相對高），如果只是方向鍵放開的情況會小小滑行，而急著需要轉方向的時候會很快地改變方向。</li><li>在空中會比較慣性運動（減速度很低），加速度與地面相同代表你可以做到「先垂直起跳，然後往前移動」的超人動作，轉向速度比減速度高代表你有一定程度改變方向的能力（C 字跳）。</li></ul><blockquote><p>空中的水平移動還有一些變種參數，比如有些遊戲會引入空中摩擦力（Air Friction），讓水平速度降低，形成非對稱跳躍曲線，後面會提到。</p></blockquote><h2 id="幾款經典橫向遊戲的參數"><a class="markdownIt-Anchor" href="#幾款經典橫向遊戲的參數"></a> 幾款經典橫向遊戲的參數</h2><p>這裡引用論文數據，圖中橘線表示按鍵按下去的時間點，綠線代表放開的時間點。</p><h3 id="castlevania-惡魔城"><a class="markdownIt-Anchor" href="#castlevania-惡魔城"></a> Castlevania 惡魔城</h3><p><img src="/images/bb-001-character-controller/2023-07-23T000611.png" alt="" /><br /><img src="/images/bb-001-character-controller/horizontal_movement_castle.gif" alt="用 Platformer Toolkit 模擬 Castlevania 效果" /><br />典型的只有全速和零速度的設計，就是根本沒有實作加速度的機制，也可以理解成加速度、減速度都無限大。<br />早年重戰鬥的動作遊戲都這樣（沒記錯的話洛克人也是），好處是反應速度快，可控性高。</p><h3 id="super-meat-boy"><a class="markdownIt-Anchor" href="#super-meat-boy"></a> <a href="https://store.steampowered.com/app/40800/Super_Meat_Boy/">Super Meat Boy</a></h3><p><img src="/images/bb-001-character-controller/2023-07-23T000715.png" alt="" /><br /><img src="/images/bb-001-character-controller/horizontal_movement_smb.gif" alt="用 Platformer Toolkit 模擬 Super Meat Boy 效果" /><br />Super Meat Boy 採用低加速度的設計，讓玩家有一個累積速度的過程。<br />特別的是他的減速度無限大，代表你手一放開就停止了，這個設計怪怪的比較像 bug ，晚點會提。</p><h3 id="super-mario-bros-超級瑪利歐兄弟"><a class="markdownIt-Anchor" href="#super-mario-bros-超級瑪利歐兄弟"></a> Super Mario Bros 超級瑪利歐兄弟</h3><p><img src="/images/bb-001-character-controller/2023-07-23T000735.png" alt="" /><br /><img src="/images/bb-001-character-controller/horizontal_movement_mario.gif" alt="用 Platformer Toolkit 模擬 Mario 效果" /><br />瑪利歐就是典型的低加速低減速的超高慣性運動，會讓人有很滑很飄的控制感。</p><h3 id="limbo"><a class="markdownIt-Anchor" href="#limbo"></a> <a href="https://store.steampowered.com/app/48000/LIMBO/">LIMBO</a></h3><p><img src="/images/bb-001-character-controller/2023-07-23T000803.png" alt="" /><br /><img src="/images/bb-001-character-controller/horizontal_movement_limbo.gif" alt="用 Platformer Toolkit 模擬 LIMBO 效果" /><br />LIMBO 跟瑪利歐設計一樣是加減速一致，但強度比較高所以更可控一點。<br />但它的數據比較特別的是最大速度和加速度都會受到輸入的值影響，而且不是線性成長。</p><h3 id="轉向加速度turn-acceleration"><a class="markdownIt-Anchor" href="#轉向加速度turn-acceleration"></a> 轉向加速度（Turn Acceleration）</h3><p>然後是它們各自的轉向加速度，因為 Castlevania 本來就可以瞬間轉向就不列了。<br /><img src="/images/bb-001-character-controller/2023-07-23T002243.png" alt="圖片中的橘線表示按下反方向輸入的時間點，綠線表示速度到達 0 的時間點。" /></p><p>看到這，有沒有感覺哪裡怪怪的？</p><p><strong>Super Meat Boy 的轉向加速度（Turn Acceleration）竟然比它的減速度（Deceleration）還低！</strong></p><p>這代表什麼？<br />「如果你在 Super Meat Boy 中想要緊急改變方向，那你應該直接放開移動鍵，讓角色瞬間停下來，之後再推動方向鍵去讓玩家加速。」</p><p>這個設計超級問號的，因為所有玩家想要緊急改變方向的直覺反應都是<strong>直接反向輸入</strong>，但你這樣做反而會滑行更久。所以我偏向認為只是開發者設定錯誤而已，減速度不應該是無限大才對。</p><table><thead><tr><th>放開移動輸入</th><th>往反方向輸入</th></tr></thead><tbody><tr><td><img src="/images/bb-001-character-controller/super_meat_boy_1.gif" alt="放開移動輸入" /></td><td><img src="/images/bb-001-character-controller/super_meat_boy_2.gif" alt="往反方向輸入" /></td></tr></tbody></table><h3 id="數值表格"><a class="markdownIt-Anchor" href="#數值表格"></a> 數值表格</h3><p>最後論文有幫我們整理成一張表格，直接看數字比較清楚：<br /><img src="/images/bb-001-character-controller/2023-07-23T002341.png" alt="各個經典 2D Platformer 的水平速度參數表格" /></p><blockquote><p>嚴格來說水平速度參數組的選擇沒有對錯，舉這些經典遊戲的例子是希望幫助你了解數值為什麼這樣設計，它們能帶來什麼樣的效果。</p></blockquote><h2 id="使用更好的單位來表達-時間秒數"><a class="markdownIt-Anchor" href="#使用更好的單位來表達-時間秒數"></a> 使用更好的單位來表達 – 時間（秒數）</h2><p>比起直接以「每秒增加多少速度（u/s）」作為單位，以設計師立場使用「加速幾秒後會到達最高速（s）」會更直觀方便。<br />用上面提供的數值表格為例就是以 Duration 來設計。<br />以前面說的速度參數組為例的話，改成以下這樣的參數形式會比較方便做數值設計：</p><ul><li>速度最大值（單位/秒）</li><li>從速度 0 到達速度最大值要多久（秒）</li><li>不做任何輸入的話，從速度最大值降到零要多久 （秒）</li><li>往反方向輸入，從速度最大值降到零要多久（秒）</li></ul><p>除非你要做什麼更精細的加減速變化又很難反向推導出以時間為參數的公式，否則這樣的設計比較好。</p><p><em>感謝 <a href="https://twitter.com/TaDavidYu">Ta David Yu</a> 特別點出這件事情:D</em></p><h1 id="2-跳躍速度-高度與重力gravity"><a class="markdownIt-Anchor" href="#2-跳躍速度-高度與重力gravity"></a> 2. 跳躍速度、高度與重力（Gravity）</h1><p>這部分有以下這些數值要考慮：</p><ol><li>起跳速度（Takeoff Velocity）</li><li>重力加速度 （g）</li><li>跳躍高度</li><li>跳躍上升到最高點要花多久時間（單位: 秒）</li></ol><p>這裡列了 4 個數值，但實際上<strong>參數只會有 2 個</strong>，只要你決定了要設定其中任意兩個參數，剩下那兩個數值都能經由公式得出數值。</p><p>製作 Bionic Bay 的時候，我們採用了設定「跳躍高度」和「重力加速度」這兩個數值。<br />剩下的起跳速度、上升/下降時間都可以透過這兩個參數計算得出。</p><ul><li>以「跳躍高度」做數值設計很方便，尤其因為它跟關卡設計息息相關。</li><li>「重力加速度」是相對比較沒那麼有利於數值設計的參數，一般會認為世界的重力加速度就是一個固定的加速度，對所有的物件都有一樣的效果<br />，在現實是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9.80665</mn><mi>m</mi><mi mathvariant="normal">/</mi><msup><mi>s</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">9.80665 m/s^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mord">.</span><span class="mord">8</span><span class="mord">0</span><span class="mord">6</span><span class="mord">6</span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，但在遊戲中就要看你的度量單位，以及你想要怎麼樣的效果（主要影響到上升到頂端的速度、下墜速度）。</li><li>如果遊戲本身並不在乎重力一致性（所有物件、角色的重力不需要一樣）的話，或是整個遊戲你只在乎主角本身的跳躍感受，那可以改採用「跳躍上升到最高點要花多久時間」作為參數來推導出重力加速度，設計上會更加直覺。</li><li>「起跳速度」我認為最不需要直接當成參數給設計師調整，但在程式實作上會以這個來推動物理。</li></ul><p>另外值得提的是有些遊戲會有所謂 <strong>Terminal Velocity</strong> ，代表<strong>最高的下墜速度</strong>，就是說角色下墜速度絕對不會比這個速度更快。<br /><img src="/images/bb-001-character-controller/2023-07-23T004744.png" alt="Mario 和 Braid 就明顯有 Terminal Velocity 存在。" /></p><p><em>（Platformer Toolkit 把 Terminal Velocity 參數放在 Assists 類別）</em></p><p>而剩下也沒什麼其他參數了，Toolkit 裡面是多附贈了一個 <strong>Down Gravity</strong> 參數，是讓你墜落時所受到的重力加速度比上升中還要大，使得落地時間減少。<br /><img src="/images/bb-001-character-controller/down_gravity_1.gif" alt="在 Platformer Toolkit 中你可以拉動 Down Gravity 拉桿使得角色墜落更快" /><br />我自己沒有很喜歡這種重力感就沒實作在 Bionic Bay 上。<br />例如 <a href="https://maddymakesgames.com/articles/celeste_and_forgiveness/index.html">Celeste 就有用這招</a>，不過他的本意是反過來 – 「讓起跳上升期間的重力減半」，而且效果很輕微，因為它本身的 Terminal Velocity 很低（很快就進入等速墜落）所以它用這個的代價也很低。<br /><img src="https://maddymakesgames.com/articles/celeste_and_forgiveness/images/3.gif" alt="" /><br /><em>圖片出處：<a href="https://maddymakesgames.com/articles/celeste_and_forgiveness/index.html">Celeste &amp; Forgiveness</a></em></p><blockquote><p>雖然直接使用 Down Gravity 的效果我不喜歡，但 Down Gravity 的概念在下面會提到的「<a href="#3-%E5%8F%AF%E6%8E%A7%E5%88%B6%E7%9A%84%E8%B7%B3%E8%BA%8D%E9%AB%98%E5%BA%A6variable-height">可控制的跳躍高度</a>」被發揚光大。</p></blockquote><h2 id="幾款經典橫向遊戲的參數-2"><a class="markdownIt-Anchor" href="#幾款經典橫向遊戲的參數-2"></a> 幾款經典橫向遊戲的參數</h2><h3 id="super-meat-boy-2"><a class="markdownIt-Anchor" href="#super-meat-boy-2"></a> Super Meat Boy</h3><p><img src="/images/bb-001-character-controller/2023-07-23T011340.png" alt="" /><br />這是非常典型的對稱跳躍曲線，沒有多做任何特別參數處理的結果。</p><h3 id="super-mario-bro"><a class="markdownIt-Anchor" href="#super-mario-bro"></a> Super Mario Bro</h3><p><img src="/images/bb-001-character-controller/2023-07-23T011614.png" alt="瑪利歐的起跳速度與當前水平速度掛勾" /><br />瑪利歐有個很妙的設計 – 你水平移動速度越快就能跳得越高，就是在鼓勵你全速移動、助跑跳高。</p><blockquote><p>至於你可能會發現瑪利歐的曲線是<strong>非對稱</strong>的（最高點稍微往右偏），這代表它也有 Down Gravity 嗎？（在 Platformer Toolkit 的瑪利歐 preset 中是把它當成是有 Down Gravity 的設計）<br />先說結論，它<strong>並沒有 Down Gravity</strong>。真正的原因是下面會提到的「可控制跳躍高度」設計。</p></blockquote><h3 id="limbo-2"><a class="markdownIt-Anchor" href="#limbo-2"></a> LIMBO</h3><p><img src="/images/bb-001-character-controller/2023-07-23T012508.png" alt="LIMBO 同瑪利歐的設計" /><br />LIMBO 也承襲了瑪利歐的助跑跳高設計，不過 LIMBO 加速過程也就 0.2 秒，所以單就這個設計的實際差異不大。<br />也因此有了以下一個新設計：<br /><img src="/images/bb-001-character-controller/2023-07-23T012835.png" alt="LIMBO 以一個固定距離為基準線，會區分成短跳和長跳" /><br />基於助跑距離是否有超出一個範圍，會區分成短跳和長跳，短跳的起跳速度較低，進而鼓勵玩家助跑跳躍。</p><p>LIMBO 還有個更特別的設計是它的起跳速度（Takeoff Velocity）是有額外的水平向前速度。<br /><img src="/images/bb-001-character-controller/2023-07-23T013515.png" alt="藍線是假設不包含向前速度的跳躍曲線，紅色是實際加上了向前速度的跳躍曲線" /><br />雖然幅度不大，但它可以讓你在前跳的時候獲得一定量向前的速度。</p><blockquote><p>你可能又會發現 LIMBO 的跳躍曲線也是<strong>非對稱</strong>的，這是因為它有空氣摩擦力（Air Friction）設計，它會讓角色在空中的水平移動的速度持續衰減。</p></blockquote><h3 id="數值表格-2"><a class="markdownIt-Anchor" href="#數值表格-2"></a> 數值表格</h3><p><img src="/images/bb-001-character-controller/2023-07-23T015404.png" alt="各個經典 2D Platformer 的起跳速度與重力參數表格" /></p><h1 id="3-可控制的跳躍高度variable-height"><a class="markdownIt-Anchor" href="#3-可控制的跳躍高度variable-height"></a> 3. 可控制的跳躍高度（Variable Height）</h1><p>又可以稱「動態跳躍高度」的功能，概念是「按住跳躍輸入越久跳越高，按住時間越短跳越低」。<br /><img src="/images/bb-001-character-controller/variable_jump_1.gif" alt="注意一下圖中的 SPACE 鍵代表跳躍的輸入，按住越久跳得越高，快速放開按鍵就只會小跳" /></p><p>不過光這個單一概念就可以有好幾種實作方法，這邊會列出三種做法。</p><h2 id="放開時上升速度直接歸零"><a class="markdownIt-Anchor" href="#放開時上升速度直接歸零"></a> 放開時，上升速度直接歸零</h2><p>讓按住跳躍鍵的結果等同於原始跳躍高度，但是一放開按鍵就會讓上升速度歸零。<br />這應該是很常見的做法，因為實作非常簡單，而做出來的效果會非常有立即性（因為放開的瞬間即跳躍的最高點）。<br />現有案例：Super Meat Boy。<br /><img src="/images/bb-001-character-controller/2023-07-23T020231.png" alt="Super Meat Boy 採用直接歸零的實作" /><br />這個做法讓玩家<strong>可控性</strong>最高，缺點是<strong>小跳的跳躍軌跡不自然</strong>，因為放開按鍵的瞬間角色會直接停止並開始墜落，少了「減速過程」。</p><blockquote><p>GMTK Platformer Toolkit 採用這個實作。</p></blockquote><h2 id="按住時持續給予向上的力"><a class="markdownIt-Anchor" href="#按住時持續給予向上的力"></a> 按住時，持續給予向上的力</h2><p>讓瞬按瞬放的跳躍結果等同於原始設定的跳躍高度，但你如果有按住的話會持續給予一個向上的力（直到消耗完為止）。<br />這是瑪利歐的做法，這個做法跟上一個做法可以說完全相反，我不確定有沒有其他遊戲也這樣做。<br /><img src="/images/bb-001-character-controller/2023-07-23T021324.png" alt="瑪利歐採用按住會持續獲得上升力的方式" /><br />這個做法的玩家可控性稍差一點（因為放開後還要一段時間才到頂端），優點是跳躍曲線比較好看、自然。<br />但缺點很明顯，<strong>大跳的上升軌跡不太自然</strong>、數值不好設計（因為你設定的起始跳躍高度是小跳高度）。</p><h2 id="放開時給予一個向下的力down-gravity"><a class="markdownIt-Anchor" href="#放開時給予一個向下的力down-gravity"></a> 放開時，給予一個向下的力（Down Gravity）</h2><p>讓按住跳躍鍵的結果等同於原始跳躍高度，但是一放開按鍵就會被添加一個額外的 Down Gravity 來把原始的起跳速度（Takeoff Velocity）抵銷掉為止。<br />這算是第一種方法的改良版，可以解決<strong>小跳的不自然感</strong>，缺點是可控性就降低了一點（因為放開後還要一段時間才到頂端）。<br />現有案例： <a href="https://store.steampowered.com/app/48000/LIMBO/">LIMBO</a> 、 <a href="https://store.steampowered.com/app/261570/Ori_and_the_Blind_Forest/">Ori and the Blind Forest</a> 、 <a href="https://store.steampowered.com/app/1928690/Bionic_Bay/?utm_source=pedevsite&amp;utm_medium=post&amp;utm_campaign=bb001">Bionic Bay</a>。</p><p><img src="/images/bb-001-character-controller/2023-07-23T022237.png" alt="我們 Bionic Bay 最終採用這個方案，我自己也覺得這是多數情況的最佳解。" /></p><p>實作上要稍微注意的點是，它的目的是「抵銷起跳速度」，並不是單純的讓下降的重力變大，當你的原始起跳速度已經被重力抵銷完了（即按住大跳的情況）就沒必要在加額外的 Down Gravity 了。</p><blockquote><p>這裡用 Down Gravity 是為了對應文章前面提及的，論文中的用詞是 Release Drag。</p></blockquote><h1 id="4-coyote-time-edge-jump-邊緣跳躍"><a class="markdownIt-Anchor" href="#4-coyote-time-edge-jump-邊緣跳躍"></a> 4. Coyote Time / Edge Jump （邊緣跳躍）</h1><p>這個專有名詞眾說紛紜，也有被稱為 <a href="http://kpulv.com/123/Platforming_Ledge_Forgiveness/">Platforming Ledge Forgiveness</a>。<br />因為 Celeste 做太好了所以我就一律用他們使用的名詞 Coyote Time 來稱呼了。<br />這個「輔助功能」直接看 Celeste 的 GIF 圖就能懂了：<br /><img src="https://maddymakesgames.com/articles/celeste_and_forgiveness/images/1.gif" alt="人物已經離開地面了才跳躍" /><br /><em>圖片出處：<a href="https://maddymakesgames.com/articles/celeste_and_forgiveness/index.html">Celeste &amp; Forgiveness</a></em></p><p>硬要說明的話就是「當角色離地後 N 毫秒內仍可以進行跳躍動作」。</p><p>這個實作非常簡單，以 Unity-style C# 寫個範例碼，假設這是原本的角色跳躍寫法：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">// 每幀更新呼叫此方法</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name"><span class="token keyword">bool</span></span> isGrounded <span class="token operator">=</span> <span class="token function">CheckGround</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 檢測角色目前是否站在地面上</span>  <span class="token class-name"><span class="token keyword">bool</span></span> inputJump <span class="token operator">=</span> <span class="token function">GetInputJump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否按下跳躍鍵</span>  <span class="token comment">// 如果在地面上並且按下跳躍鍵，即可執行跳躍</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>isGrounded <span class="token operator">&amp;&amp;</span> inputJump<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">Jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把<strong>可跳躍判定</strong>從 <code>isGrounded</code> 換成 <code>coyoteTime &gt; 0</code> 就好，如下：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">const</span> <span class="token class-name"><span class="token keyword">float</span></span> TOLERANCE <span class="token operator">=</span> <span class="token number">0.05f</span><span class="token punctuation">;</span> <span class="token comment">// 離地後有 0.05 秒的時間容許跳躍</span><span class="token class-name"><span class="token keyword">float</span></span> m_CoyoteTime<span class="token punctuation">;</span> <span class="token comment">// coyote time 的剩餘時間</span><span class="token comment">// 每幀更新呼叫此方法</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name"><span class="token keyword">bool</span></span> isGrounded <span class="token operator">=</span> <span class="token function">CheckGround</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 檢測角色目前是否站在地面上</span>  <span class="token class-name"><span class="token keyword">bool</span></span> inputJump <span class="token operator">=</span> <span class="token function">GetInputJump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否按下跳躍鍵</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isGrounded<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    m_CoyoteTime <span class="token operator">=</span> TOLERANCE<span class="token punctuation">;</span> <span class="token comment">// 站在地面上就設定 coyote time</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    m_CoyoteTime <span class="token operator">-=</span> Time<span class="token punctuation">.</span>deltaTime<span class="token punctuation">;</span> <span class="token comment">// 如果沒有站在地面上就開始倒數</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 如果 coyote time 還沒倒數至 0 並且按下跳躍鍵，即可執行跳躍</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>m_CoyoteTime <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> inputJump<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">Jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我認為這真的是一個實作超級簡單，效果又超棒的功能。很多遊戲只要加入這個，平台之間的跳躍體驗就大幅上升。<br />不過雖然知識和實作都超簡單，也還是有大 IP 作品沒實作這件事情（<s>對我就是在說 Metroid Dread</s>），所以你有做至少就大概 PR70 以上了。</p></blockquote><h1 id="5-跳躍輸入緩衝-jump-buffering-jump-cache"><a class="markdownIt-Anchor" href="#5-跳躍輸入緩衝-jump-buffering-jump-cache"></a> 5. 跳躍輸入緩衝 （Jump Buffering / Jump Cache）</h1><p>為你的<strong>跳躍輸入按鍵</strong>加入緩衝（buffer），就是<br />「輸入跳躍按鍵的當下若還無法觸發跳躍，在之後的 N 秒內只要有進入可跳躍的狀態，仍會自動觸發跳躍」<br />整句很繞口，看下面 GIF 圖比較好理解。<br />這是在 Bionic Bay 實作的效果，情境是在角色快落地的時候再次按下跳躍鍵（圖中的 SPACE 亮起代表按下）。</p><table><thead><tr><th>開啟輸入緩衝</th><th>關閉</th></tr></thead><tbody><tr><td><img src="/images/bb-001-character-controller/jump_buffering_1.gif" alt="快落地前按下跳躍能夠成功跳起來" /></td><td><img src="/images/bb-001-character-controller/jump_buffering_2.gif" alt="快落地前按下跳躍但跳不起來" /></td></tr></tbody></table><p><em>我從來沒想過為了遊戲教學寫的 Replay 系統可以在寫文章用上</em></p><p>需要這個輸入緩衝的原因是「當玩家預期要在角色落地的瞬間馬上再跳起來的話，通常都會<strong>早按</strong>」。如果你沒有做這個輸入緩衝的話會導致角色跳不起來，玩家就會怪罪遊戲說「我明明就按了啊」。</p><blockquote><p>輸入緩衝真的超重要，而且不只跳躍輸入要緩衝，任何有這種需要抓準時機按下的按鍵都最好要有一定的緩衝時間（e.g. 攻擊、迴避、招架），否則玩家會一直怪罪遊戲判定不良。這和遊戲上常討論到的判定窗口（window）是類似概念但不同形式。</p></blockquote><h1 id="6-自適應-collider-hitbox-pinching-階梯處理"><a class="markdownIt-Anchor" href="#6-自適應-collider-hitbox-pinching-階梯處理"></a> 6. 自適應 Collider / Hitbox Pinching / 階梯處理</h1><p><em>從這裡開始 GMTK Platformer Toolkit 就沒有實作了。</em></p><p>這裡引用 <a href="https://store.steampowered.com/app/792710/Levelhead_Platformer_Maker/">LevelHead</a> 開發者在 GDC 2020 分享的 <a href="https://youtu.be/HCnZhs-92j0?t=1108">Forgiveness Mechanics: Reading Minds for Responsive Gameplay</a> 來介紹這個輔助功能。</p><p>要解決的情境如下圖：<br /><img src="/images/bb-001-character-controller/2023-07-23T120748.png" alt="人物是橘色方塊要往右走，但前方有突起物" /><br />角色的前方有一個小突起物（階梯）擋住你的移動路徑，什麼都沒處理的話往前移動會被它卡住。</p><p>有一個 Naive 解是 – 「把你的角色 Collider 換成圓角形狀（Rounded Corners）」，比如說 Circle Collider 或 Capsule Collider ，這樣一來即便你直接撞上去也 <em>有機會</em> 讓物理引擎幫你解決。但這個方法的效果不夠穩定實用，而且弄不好甚至有機會在撞上去的瞬間讓你的人直接起飛。</p><p>而這篇要介紹的穩定實用方法是「當你移動的時候縮小碰撞範圍（Hitbox）」。<br />如下圖把碰撞範圍縮小至黃色區域：<br /><img src="/images/bb-001-character-controller/2023-07-23T120844.png" alt="縮小人物碰撞範圍（高度）藉以通過突起物" /></p><p>但是這並不是單純讓角色的 Collider 變矮然後就往下墜落，重點是「角色的碰撞範圍縮小後，依然保持與地面相同的距離」。<br />所以當角色成功站上突起物之後，也要讓它與新的地面高度保持原本的距離，也就是往上升。<br />可以直接看這個三步驟 GIF 示意圖：<br /><img src="/images/bb-001-character-controller/hitbox_pinch_1.gif" alt="踩上突起地面後要校正成原始的離地高度，後面兩步實際上是一次做完的" /></p><h2 id="應用案例"><a class="markdownIt-Anchor" href="#應用案例"></a> 應用案例</h2><p>一樣先用 LevelHead 提供的例子</p><table><thead><tr><th>沒有使用 Hitbox Pinching</th><th>使用 Hitbox Pinching</th></tr></thead><tbody><tr><td><img src="/images/bb-001-character-controller/hitbox_pinch_2.gif" alt="" /></td><td><img src="/images/bb-001-character-controller/hitbox_pinch_3.gif" alt="" /></td></tr></tbody></table><p>再來其實<strong>並不是只有水平移動可以用這招，垂直跳躍也能用</strong>。<br /><img src="/images/bb-001-character-controller/hitbox_pinch_4.gif" alt="縮小 Hitbox 的軸向從原本的縮高度換成縮寬度，可以減少撞到頭的情況" /></p><p>而 <a href="https://store.steampowered.com/app/504230/Celeste/">Celeste</a> 也有大量使用這招：<br /><img src="https://maddymakesgames.com/articles/celeste_and_forgiveness/images/4.gif" alt="" /><br /><img src="https://maddymakesgames.com/articles/celeste_and_forgiveness/images/5.gif" alt="" /><br /><img src="https://maddymakesgames.com/articles/celeste_and_forgiveness/images/6.gif" alt="" /><br /><em>圖片出處：<a href="https://maddymakesgames.com/articles/celeste_and_forgiveness/index.html">Celeste &amp; Forgiveness</a></em></p><p>最後是在 Bionic Bay 的應用：<br /><img src="/images/bb-001-character-controller/hitbox_pinch_5.gif" alt="克服階梯問題" /></p><p>實際上關卡中不會刻意設計這種階梯，但這個功能可以大幅度地降低角色被場景各種縫隙、突起給卡住的情況</p><table><thead><tr><th><img src="/images/bb-001-character-controller/hitbox_pinch_6.gif" alt="走在畸形物體表面上1" /></th><th><img src="/images/bb-001-character-controller/hitbox_pinch_7.gif" alt="走在畸形物體表面上2" /></th></tr></thead><tbody></tbody></table><blockquote><p>這個功能的實作依據角色移動的具體方法和地圖設計的不同而有不同的實作形式。</p><ul><li>比較傳統 Retro 類型的平台跳躍因為通常是 Tile-based 的地圖設計和更精準的角色控制方法（移動方式是基於程式碼直接對 position 進行控制），只考慮可操控角色本身的話會比較簡單實作。</li><li>Bionic Bay 因為是物理驅動（移動方式是設定 velocity 之後再交由物理引擎去跑）加上地形非常混亂不規則，採取的實作方式更接近通用 3D Character Controller 的形式，坑很多，實作有參考這兩個 Unity Assets：<a href="https://assetstore.unity.com/packages/tools/physics/kinematic-character-controller-99131">Kinematic Character Controller</a>、<a href="https://assetstore.unity.com/packages/tools/physics/character-controller-pro-159150">Character Controller Pro</a>，之後的文章會再補上具體是怎麼做的。</li></ul></blockquote><h1 id="7-邊緣偵測與落地校正"><a class="markdownIt-Anchor" href="#7-邊緣偵測與落地校正"></a> 7. 邊緣偵測與落地校正</h1><p>這邊引用 <a href="https://store.steampowered.com/app/588650/Dead_Cells/">Dead Cells</a> 在 TGDF 2018 的演講 <a href="https://youtu.be/bu-RbmjvltU?t=1019">使玩家感覺良好 – 《Dead Cells》開發回顧</a> 的影片片段 – 「跳躍於平台之間」。</p><p>他們實作了所謂的「Cheating on arrival」，意思是「當角色在降落於「靠近平台邊緣」的時候，會自動校正落地點於平台之上」。<br />直接看比較圖：</p><table><thead><tr><th>Cheating on arrival</th><th>None</th></tr></thead><tbody><tr><td><img src="/images/bb-001-character-controller/ledge_tolerance_1.gif" alt="" /></td><td><img src="/images/bb-001-character-controller/ledge_tolerance_2.gif" alt="" /></td></tr></tbody></table><p>這個概念是因為以玩家視角不會諒解所謂的「啊就剛好你的 Collider 就只差了一點點才能踩到地板，所以摔下去了」。<br />邏輯跟前面輸入緩衝（Buffering）的概念差不多，玩家的預期心理與實際上物理結果並不是一致的。</p><blockquote><p>實作上你如果有做第六點的縮 Collider 輔助的話，其實就能達成類似的效果。因為在 collider 有縮的情況下，這樣的橫向跳躍的落地距離就可以有效增加（想像一下右圖無法踩到地是因為腳那區塊的 collider 撞到牆）。<br />但這裡講的<strong>落地校正</strong>是去主動偵測前方的落地點並讓整個角色座標位移。</p></blockquote><p>不過我們取其精神即可，實作上不一定要學 Dead Cells 的<strong>落地校正</strong>。</p><p>以我們 Bionic Bay 來說，邊角攀附（Ledge Grab）機制就能做到一樣的效果。<br /><img src="/images/bb-001-character-controller/ledge_tolerance_3.gif" alt="" /></p><p>慢動作看：<br /><img src="/images/bb-001-character-controller/ledge_tolerance_4.gif" alt="綠色框框是抓取判定範圍，注意看人原本看起來已經掉下去了，但判定夠大可以抓回去" /></p><h1 id="結語"><a class="markdownIt-Anchor" href="#結語"></a> 結語</h1><p>以上是我想的到且我個人認為比較<strong>通用</strong>的「移動」和「跳躍」的知識點。<br />可能還有什麼通用招式是我不知道的，歡（拜）迎（託）跟我說一下。</p><p>實務上還會依據個別遊戲的不同去強化輔助不同的功能，不過核心理念都一樣，就是<br />「不要讓玩家被非刻意設計的小瑕疵卡住，讓玩家把時間花在開發者刻意設計的挑戰才是最重要的事」。</p><blockquote><p>但也不是說把以上知識全部做到就能讓所有玩家滿意，實際上也是有玩家覺得 <a href="https://store.steampowered.com/app/1928690/Bionic_Bay/?utm_source=pedevsite&amp;utm_medium=post&amp;utm_campaign=bb001">《Bionic Bay: 換影循跡》</a> 的操作很滑很爛，這裡就直接引用我朋友說的：<br />「往好處想就是沒寫這堆功能就更爛」。<br />舉例來說光<strong>速度參數</strong>和<strong>跳躍曲線</strong>的選擇就一定會分好幾派了，你不可能滿足所有人。<s>除非你做一個可以自由調整參數的 meta 遊戲</s></p></blockquote><h1 id="參考資料和補充"><a class="markdownIt-Anchor" href="#參考資料和補充"></a> 參考資料和補充</h1><p>礙於篇幅，我只整理了我覺得重要的知識點，有空的話可以直接看參考資料本身，他們都講得非常詳盡，一定對開發有幫助。</p><ul><li><a href="http://martinf.dk/jump/">You Say Jump, I Say How High?</a></li><li><a href="https://gmtk.itch.io/platformer-toolkit">GMTK Platformer Toolkit</a></li><li>Celeste 系列<ul><li><a href="https://github.com/NoelFB/Celeste">Source Code</a></li><li><a href="https://www.youtube.com/watch?v=yorTG9at90g">Why Does Celeste Feel So Good to Play?</a></li><li><a href="https://maddymakesgames.com/articles/celeste_and_forgiveness/index.html">Celeste &amp; Forgiveness</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=HCnZhs-92j0">Forgiveness Mechanics: Reading Minds for Responsive Gameplay</a></li><li><a href="https://www.youtube.com/watch?v=bu-RbmjvltU">使玩家感覺良好 – 《Dead Cells》開發回顧</a></li><li><a href="https://assetstore.unity.com/packages/tools/physics/kinematic-character-controller-99131">Kinematic Character Controller (Asset Store)</a></li></ul><p>雖然文章內沒有引用，但我覺得還是值得一看的資料：</p><ul><li><a href="https://forums.tigsource.com/index.php?topic=46289.1040">Leilani’s Island Devlog</a></li><li><a href="https://home.gamer.com.tw/artwork.php?sn=5125027">遊戲開發日誌 #8 系統移轉、Coyote Time、轉角補正 etc.</a> &lt;— 寫這篇的時候翻到一個國內有為青年的獨立開發日誌，幫推</li><li><a href="http://higherorderfun.com/blog/2012/05/20/the-guide-to-implementing-2d-platformers/">The guide to implementing 2D platformers</a></li><li><a href="https://catlikecoding.com/unity/tutorials/movement/">Unity Movement Tutorials - Catlike Coding</a></li></ul><p>文章中 GIF 圖片的製作使用了：</p><ul><li><a href="https://www.screentogif.com/">ScreenToGif</a> - 開源好物，可以很方便地錄製螢幕指定區域（可輸出 gif 或影片格式）。</li><li><a href="https://github.com/qwe321qwe321qwe321/vid2gif-ffmpeg-gifski">vid2gif-ffmpeg-gifski</a> - 本人寫的一個能夠快速地把影片檔轉換成高品質高壓縮率的 GIF 圖片的小工具（整合 <a href="https://github.com/FFmpeg/FFmpeg">ffmpeg</a> 和 <a href="https://gif.ski/">gifski</a> 這兩套開源軟體的應用）。</li></ul><h1 id="致謝-acknowledgements"><a class="markdownIt-Anchor" href="#致謝-acknowledgements"></a> 致謝 Acknowledgements</h1><p>感謝 <a href="https://twitter.com/RandomDevDK">DK Liao</a>、<a href="https://twitter.com/LaiLie0126">Kevin Lai</a>、Mayavi、<a href="https://twitter.com/TaDavidYu">Ta David Yu</a> 的校閱。</p><hr /><h1 id="後話-next"><a class="markdownIt-Anchor" href="#後話-next"></a> 後話 Next?</h1><p>回到開頭的 Bionic Bay 角色控制器展示，但整篇文完全沒有提到那些列出來的功能，這一篇的內容是屬於角色移動的核心模組、水平移動模組、跳躍模組的範疇內。而配合物理的各項機制因為並不算「通用」，應該也可以說是偏門，放在這一篇就不太適合。</p><p>下一篇預計會寫更特定主題、特定遊戲才適用的功能實作。<br />.<br /><em>如果真有下一篇的話。</em><br />.<br />光這篇就耗費了整個週末邊聽 <a href="https://2023.tgdf.tw/">TGDF</a> 邊寫，之後一個禮拜還持續在更改內容、補圖片 etc。深深感覺到自己寫爽的紀錄文和希望分享給別人看的文章差太多了，因為怕誤導讀者所以需要各種勘誤、檢視文字用法是一件超級花時間的事，真的敬佩所有願意寫文章、演講分享的人。<br />所以預防針一下如果真有下一篇那也只會是記錄用的自爽文，應該不會刻意在 SNS 分享。</p><p>另外這一篇之後還得花時間寫成英文版，<s>希望能洗點國外開發者的好感度。</s></p>]]></content>
    
    
    <summary type="html">介紹一下優秀 2D 平台跳躍 / 橫向卷軸遊戲的角色控制中「移動」和「跳躍」會用到的一些通用知識，主要都是整理自網路上的資源和我實際在 Bionic Bay 上的應用。</summary>
    
    
    
    
    <category term="Unity" scheme="https://qwe321qwe321qwe321.github.io/tags/Unity/"/>
    
    <category term="Gamedev" scheme="https://qwe321qwe321qwe321.github.io/tags/Gamedev/"/>
    
    <category term="Bionic Bay" scheme="https://qwe321qwe321qwe321.github.io/tags/Bionic-Bay/"/>
    
    <category term="Physics" scheme="https://qwe321qwe321qwe321.github.io/tags/Physics/"/>
    
    <category term="BB-devlog" scheme="https://qwe321qwe321qwe321.github.io/tags/BB-devlog/"/>
    
  </entry>
  
  <entry>
    <title>Embed GlslEditor in Markdown</title>
    <link href="https://qwe321qwe321qwe321.github.io/posts/21941/"/>
    <id>https://qwe321qwe321qwe321.github.io/posts/21941/</id>
    <published>2022-10-11T08:14:24.000Z</published>
    <updated>2022-10-11T08:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="glsleditor"><a class="markdownIt-Anchor" href="#glsleditor"></a> GlslEditor</h1><p><a href="https://github.com/patriciogonzalezvivo/glslEditor">GlslEditor by patriciogonzalezvivo</a></p><h1 id="2d-random"><a class="markdownIt-Anchor" href="#2d-random"></a> 2D Random</h1><p>Source code is from <a href="https://thebookofshaders.com/10/">TheBookOfShaders</a></p><div  class="glslEditorCanvas"><textarea>// Author @patriciogv - 2015// http://patriciogonzalezvivo.com#ifdef GL_ESprecision mediump float;#endifuniform vec2 u_resolution;uniform vec2 u_mouse;uniform float u_time;float random (vec2 st) {    return fract(sin(dot(st.xy,                         vec2(12.9898,78.233)))*        43758.5453123);}void main() {    vec2 st = gl_FragCoord.xy/u_resolution.xy;    float rnd = random( st );    gl_FragColor = vec4(vec3(rnd),1.0);}</textarea></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;glsleditor&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#glsleditor&quot;&gt;&lt;/a&gt; GlslEditor&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/patriciogonzalezvivo</summary>
      
    
    
    
    
    <category term="Shader" scheme="https://qwe321qwe321qwe321.github.io/tags/Shader/"/>
    
    <category term="Web" scheme="https://qwe321qwe321qwe321.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>用 Hexo+Github 部屬靜態 Blog</title>
    <link href="https://qwe321qwe321qwe321.github.io/posts/31900/"/>
    <id>https://qwe321qwe321qwe321.github.io/posts/31900/</id>
    <published>2020-02-26T15:27:00.000Z</published>
    <updated>2020-02-26T15:27:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>這篇文單純記錄用hexo在github上架設靜態網站遇到的問題以及一些指令和輔助工具，以防忘記。</p><p>另外這也是第一篇用<a href="https://github.com/jaredly/hexo-admin">Hexo Admin</a>打的文章，作為嘗試。</p><span id="more"></span><h1 id="安裝hexo"><a class="markdownIt-Anchor" href="#安裝hexo"></a> 安裝Hexo</h1><p>其實不用多作介紹，網路上查的到很多教學，這邊就隨便放幾個:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/35668237">超详细Hexo+Github博客搭建小白教程</a></li><li><a href="https://medium.com/@bebebobohaha/%E4%BD%BF%E7%94%A8-hexo-gitpage-%E6%90%AD%E5%BB%BA%E5%80%8B%E4%BA%BA-blog-5c6ed52f23db">如何搭建個人 Blog 使用 Hexo + Gitpage</a></li></ul><p>甚至Hexo官網就有很齊全的教學了。</p><ul><li><a href="https://hexo.io/zh-tw/docs/">Hexo: 開始使用</a></li></ul><p>所以就不多作介紹了。</p><p>但這邊有個小問題當初卡了我一陣子，是語言和時區(timezone)到底要寫什麼才合法，<br />教學不是沒寫就是對岸的教學。總之是設定成這樣:</p><pre class="line-numbers language-none"><code class="language-none">language: zh-twtimezone: &#39;Asia&#x2F;Taipei&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="commands"><a class="markdownIt-Anchor" href="#commands"></a> Commands</h1><p><em>前提是該設定的都設定好了，如部署設定之類的。</em></p><h2 id="生成架設部署網站"><a class="markdownIt-Anchor" href="#生成架設部署網站"></a> 生成/架設/部署網站</h2><h3 id="生成靜態網頁"><a class="markdownIt-Anchor" href="#生成靜態網頁"></a> 生成靜態網頁</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo generate <span class="token punctuation">[</span>-d<span class="token punctuation">]</span> <span class="token punctuation">[</span>-w<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或用縮寫</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g <span class="token punctuation">[</span>-d<span class="token punctuation">]</span> <span class="token punctuation">[</span>-w<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>-d</code>參數會在生成後進行部署(deploy)。</p><h3 id="架設在local端"><a class="markdownIt-Anchor" href="#架設在local端"></a> 架設在Local端</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> <span class="token punctuation">[</span>-s<span class="token punctuation">]</span> <span class="token punctuation">[</span>-l<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或用縮寫</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo s <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> <span class="token punctuation">[</span>-s<span class="token punctuation">]</span> <span class="token punctuation">[</span>-l<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>便會啟動伺服器，預設是 <a href="http://localhost:4000/">http://localhost:4000/</a></p><p>參數不常用，有興趣就<a href="https://hexo.io/zh-tw/docs/commands">參考官方文件</a>。</p><h3 id="部署到遠端github"><a class="markdownIt-Anchor" href="#部署到遠端github"></a> 部署到遠端(Github)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo deploy <span class="token punctuation">[</span>-g<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或用縮寫</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo d <span class="token punctuation">[</span>-g<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>-g</code>參數會在部署網站前先產生靜態檔案。</p><p>使用這項指令前要先設定好部署到github，之後只要輸入這個指令就會自動commit並push上去。如圖</p><p><img src="/images/hexo_deploy_to_github.png" alt="會自動commit以及push至github上upload successful" /></p><h3 id="清除快取以及靜態檔案"><a class="markdownIt-Anchor" href="#清除快取以及靜態檔案"></a> 清除快取以及靜態檔案</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有些檔案更改後再次generate也不會修改，需要先清除才行。</p><h2 id="寫作"><a class="markdownIt-Anchor" href="#寫作"></a> 寫作</h2><h3 id="建立文章"><a class="markdownIt-Anchor" href="#建立文章"></a> 建立文章</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>建立一篇新的文章。如果沒有設定 layout 的話，則會使用 _config.yml 中的 default_layout 設定代替。如果標題包含空格的話，請使用引號括起來。</p><p>文章檔案放在<code>source/_posts</code>裡面</p><h4 id="layout"><a class="markdownIt-Anchor" href="#layout"></a> Layout</h4><p>Layout分為3種，<code>post</code>、<code>draft</code>、<code>page</code>。</p><ul><li><code>post</code>為一般文章存放區</li><li><code>draft</code>為草稿區，之後會用<code>publish</code>指令將草稿移至<code>post</code>。</li><li><code>page</code>為特別的頁面區，如tags、categories和about之類的頁面。</li></ul><h3 id="發表草稿"><a class="markdownIt-Anchor" href="#發表草稿"></a> 發表草稿</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo publish <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>filename<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>草稿檔案放在<code>source/_drafts</code>裡面。</p><h1 id="遇到的問題集"><a class="markdownIt-Anchor" href="#遇到的問題集"></a> 遇到的問題集</h1><ul><li><p>Q1. 使用某些主題時(如我現在使用的melody主題)會發生打開網頁時跳出以下訊息</p><pre class="line-numbers language-none"><code class="language-none">extends includes&#x2F;layout.pug block content include includes&#x2F;recent-posts.pug include includes&#x2F;pagination.pug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>A1. 你的環境缺少部分hexo套件，用以下指令安裝。<a href="https://github.com/jerryc127/hexo-theme-butterfly/issues/4">(參考來源)</a></p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-renderer-jade hexo-renderer-stylus --save or yarn add hexo-renderer-jade hexo-renderer-stylus<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Q2. 部署上去的網站與local網站長的不同</p><p>A2. 靜態文件沒有刷新，先<code>hexo clean</code>再部署一次</p></li><li><p>Q3. 將網站添加至google搜尋結果</p><p>A3. 參考<a href="https://happyhand.github.io/2018/11/29/Hexo-%E9%9A%A8%E6%89%8B%E7%AD%86%E8%A8%98-%E8%AB%8B-Google-%E8%AE%93-Blog-%E7%99%BC%E5%85%89%E7%99%BC%E7%86%B1%E5%90%A7/">這篇教學</a></p></li></ul><h1 id="第三方工具"><a class="markdownIt-Anchor" href="#第三方工具"></a> 第三方工具</h1><ul><li><a href="https://help.disqus.com/en/">Disqus</a>: 靜態網站留言版，大多數的hexo主題都有直接支援，不需要改網頁內容。小缺點是目前不知道為什麼不能設定成繁中。</li><li><a href="https://github.com/jaredly/hexo-admin">Hexo Admin</a>: Hexo線上編輯器，可以直接在網頁修改文章並發佈。</li></ul><!--stackedit_data:eyJoaXN0b3J5IjpbNzczMjI0NzEyXX0=-->]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;這篇文單純記錄用hexo在github上架設靜態網站遇到的問題以及一些指令和輔助工具，以防忘記。&lt;/p&gt;
&lt;p&gt;另外這也是第一篇用&lt;a href=&quot;https://github.com/jaredly/hexo-admin&quot;&gt;Hexo Admin&lt;/a&gt;打的文章，作為嘗試。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Github" scheme="https://qwe321qwe321qwe321.github.io/tags/Github/"/>
    
    <category term="Hexo" scheme="https://qwe321qwe321qwe321.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
